# This file was autogenerated by some hot garbage in the `uniffi` crate.
# Trust me, you don't want to mess with it!

# Tell mypy (a type checker) to ignore all errors from this file.
# See https://mypy.readthedocs.io/en/stable/config_file.html?highlight=ignore-errors#confval-ignore_errors
# mypy: ignore-errors

# Common helper code.
#
# Ideally this would live in a separate .py file where it can be unittested etc
# in isolation, and perhaps even published as a re-useable package.
#
# However, it's important that the details of how this helper code works (e.g. the
# way that different builtin types are passed across the FFI) exactly match what's
# expected by the rust code on the other side of the interface. In practice right
# now that means coming from the exact some version of `uniffi` that was used to
# compile the rust component. The easiest way to ensure this is to bundle the Python
# helpers directly inline like we're doing here.

import os
import sys
import ctypes
import enum
import struct
import contextlib
import datetime
import threading

# Used for default argument values
DEFAULT = object()


class RustBuffer(ctypes.Structure):
    _fields_ = [
        ("capacity", ctypes.c_int32),
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    @staticmethod
    def alloc(size):
        return rust_call(_UniFFILib.ffi_zklink_sdk_f180_rustbuffer_alloc, size)

    @staticmethod
    def reserve(rbuf, additional):
        return rust_call(_UniFFILib.ffi_zklink_sdk_f180_rustbuffer_reserve, rbuf, additional)

    def free(self):
        return rust_call(_UniFFILib.ffi_zklink_sdk_f180_rustbuffer_free, self)

    def __str__(self):
        return "RustBuffer(capacity={}, len={}, data={})".format(
            self.capacity,
            self.len,
            self.data[0:self.len]
        )

    @contextlib.contextmanager
    def allocWithBuilder():
        """Context-manger to allocate a buffer using a RustBufferBuilder.

        The allocated buffer will be automatically freed if an error occurs, ensuring that
        we don't accidentally leak it.
        """
        builder = RustBufferBuilder()
        try:
            yield builder
        except:
            builder.discard()
            raise

    @contextlib.contextmanager
    def consumeWithStream(self):
        """Context-manager to consume a buffer using a RustBufferStream.

        The RustBuffer will be freed once the context-manager exits, ensuring that we don't
        leak it even if an error occurs.
        """
        try:
            s = RustBufferStream(self)
            yield s
            if s.remaining() != 0:
                raise RuntimeError("junk data left in buffer after consuming")
        finally:
            self.free()


class ForeignBytes(ctypes.Structure):
    _fields_ = [
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    def __str__(self):
        return "ForeignBytes(len={}, data={})".format(self.len, self.data[0:self.len])


class RustBufferStream(object):
    """
    Helper for structured reading of bytes from a RustBuffer
    """

    def __init__(self, rbuf):
        self.rbuf = rbuf
        self.offset = 0

    def remaining(self):
        return self.rbuf.len - self.offset

    def _unpack_from(self, size, format):
        if self.offset + size > self.rbuf.len:
            raise InternalError("read past end of rust buffer")
        value = struct.unpack(format, self.rbuf.data[self.offset:self.offset+size])[0]
        self.offset += size
        return value

    def read(self, size):
        if self.offset + size > self.rbuf.len:
            raise InternalError("read past end of rust buffer")
        data = self.rbuf.data[self.offset:self.offset+size]
        self.offset += size
        return data

    def readI8(self):
        return self._unpack_from(1, ">b")

    def readU8(self):
        return self._unpack_from(1, ">B")

    def readI16(self):
        return self._unpack_from(2, ">h")

    def readU16(self):
        return self._unpack_from(2, ">H")

    def readI32(self):
        return self._unpack_from(4, ">i")

    def readU32(self):
        return self._unpack_from(4, ">I")

    def readI64(self):
        return self._unpack_from(8, ">q")

    def readU64(self):
        return self._unpack_from(8, ">Q")

    def readFloat(self):
        v = self._unpack_from(4, ">f")
        return v

    def readDouble(self):
        return self._unpack_from(8, ">d")


class RustBufferBuilder(object):
    """
    Helper for structured writing of bytes into a RustBuffer.
    """

    def __init__(self):
        self.rbuf = RustBuffer.alloc(16)
        self.rbuf.len = 0

    def finalize(self):
        rbuf = self.rbuf
        self.rbuf = None
        return rbuf

    def discard(self):
        if self.rbuf is not None:
            rbuf = self.finalize()
            rbuf.free()

    @contextlib.contextmanager
    def _reserve(self, numBytes):
        if self.rbuf.len + numBytes > self.rbuf.capacity:
            self.rbuf = RustBuffer.reserve(self.rbuf, numBytes)
        yield None
        self.rbuf.len += numBytes

    def _pack_into(self, size, format, value):
        with self._reserve(size):
            # XXX TODO: I feel like I should be able to use `struct.pack_into` here but can't figure it out.
            for i, byte in enumerate(struct.pack(format, value)):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write(self, value):
        with self._reserve(len(value)):
            for i, byte in enumerate(value):
                self.rbuf.data[self.rbuf.len + i] = byte

    def writeI8(self, v):
        self._pack_into(1, ">b", v)

    def writeU8(self, v):
        self._pack_into(1, ">B", v)

    def writeI16(self, v):
        self._pack_into(2, ">h", v)

    def writeU16(self, v):
        self._pack_into(2, ">H", v)

    def writeI32(self, v):
        self._pack_into(4, ">i", v)

    def writeU32(self, v):
        self._pack_into(4, ">I", v)

    def writeI64(self, v):
        self._pack_into(8, ">q", v)

    def writeU64(self, v):
        self._pack_into(8, ">Q", v)

    def writeFloat(self, v):
        self._pack_into(4, ">f", v)

    def writeDouble(self, v):
        self._pack_into(8, ">d", v)
# A handful of classes and functions to support the generated data structures.
# This would be a good candidate for isolating in its own ffi-support lib.

class InternalError(Exception):
    pass

class RustCallStatus(ctypes.Structure):
    """
    Error runtime.
    """
    _fields_ = [
        ("code", ctypes.c_int8),
        ("error_buf", RustBuffer),
    ]

    # These match the values from the uniffi::rustcalls module
    CALL_SUCCESS = 0
    CALL_ERROR = 1
    CALL_PANIC = 2

    def __str__(self):
        if self.code == RustCallStatus.CALL_SUCCESS:
            return "RustCallStatus(CALL_SUCCESS)"
        elif self.code == RustCallStatus.CALL_ERROR:
            return "RustCallStatus(CALL_ERROR)"
        elif self.code == RustCallStatus.CALL_PANIC:
            return "RustCallStatus(CALL_PANIC)"
        else:
            return "RustCallStatus(<invalid code>)"

def rust_call(fn, *args):
    # Call a rust function
    return rust_call_with_error(None, fn, *args)

def rust_call_with_error(error_ffi_converter, fn, *args):
    # Call a rust function and handle any errors
    #
    # This function is used for rust calls that return Result<> and therefore can set the CALL_ERROR status code.
    # error_ffi_converter must be set to the FfiConverter for the error class that corresponds to the result.
    call_status = RustCallStatus(code=RustCallStatus.CALL_SUCCESS, error_buf=RustBuffer(0, 0, None))

    args_with_error = args + (ctypes.byref(call_status),)
    result = fn(*args_with_error)
    if call_status.code == RustCallStatus.CALL_SUCCESS:
        return result
    elif call_status.code == RustCallStatus.CALL_ERROR:
        if error_ffi_converter is None:
            call_status.error_buf.free()
            raise InternalError("rust_call_with_error: CALL_ERROR, but error_ffi_converter is None")
        else:
            raise error_ffi_converter.lift(call_status.error_buf)
    elif call_status.code == RustCallStatus.CALL_PANIC:
        # When the rust code sees a panic, it tries to construct a RustBuffer
        # with the message.  But if that code panics, then it just sends back
        # an empty buffer.
        if call_status.error_buf.len > 0:
            msg = FfiConverterString.lift(call_status.error_buf)
        else:
            msg = "Unknown rust panic"
        raise InternalError(msg)
    else:
        raise InternalError("Invalid RustCallStatus code: {}".format(
            call_status.code))

# A function pointer for a callback as defined by UniFFI.
# Rust definition `fn(handle: u64, method: u32, args: RustBuffer, buf_ptr: *mut RustBuffer) -> int`
FOREIGN_CALLBACK_T = ctypes.CFUNCTYPE(ctypes.c_int, ctypes.c_ulonglong, ctypes.c_ulong, RustBuffer, ctypes.POINTER(RustBuffer))
# Types conforming to `FfiConverterPrimitive` pass themselves directly over the FFI.
class FfiConverterPrimitive:
    @classmethod
    def lift(cls, value):
        return value

    @classmethod
    def lower(cls, value):
        return value

# Helper class for wrapper types that will always go through a RustBuffer.
# Classes should inherit from this and implement the `read` and `write` static methods.
class FfiConverterRustBuffer:
    @classmethod
    def lift(cls, rbuf):
        with rbuf.consumeWithStream() as stream:
            return cls.read(stream)

    @classmethod
    def lower(cls, value):
        with RustBuffer.allocWithBuilder() as builder:
            cls.write(value, builder)
            return builder.finalize()

# Contains loading, initialization code,
# and the FFI Function declarations in a com.sun.jna.Library.
# This is how we find and load the dynamic library provided by the component.
# For now we just look it up by name.
#
# XXX TODO: This will probably grow some magic for resolving megazording in future.
# E.g. we might start by looking for the named component in `libuniffi.so` and if
# that fails, fall back to loading it separately from `lib${componentName}.so`.

from pathlib import Path

def loadIndirect():
    if sys.platform == "darwin":
        libname = "lib{}.dylib"
    elif sys.platform.startswith("win"):
        # As of python3.8, ctypes does not seem to search $PATH when loading DLLs.
        # We could use `os.add_dll_directory` to configure the search path, but
        # it doesn't feel right to mess with application-wide settings. Let's
        # assume that the `.dll` is next to the `.py` file and load by full path.
        libname = os.path.join(
            os.path.dirname(__file__),
            "{}.dll",
        )
    else:
        # Anything else must be an ELF platform - Linux, *BSD, Solaris/illumos
        libname = "lib{}.so"

    lib = libname.format("zklink_sdk")
    path = str(Path(__file__).parent / lib)
    return ctypes.cdll.LoadLibrary(path)

# A ctypes library to expose the extern-C FFI definitions.
# This is an implementation detail which will be called internally by the public API.

_UniFFILib = loadIndirect()
_UniFFILib.ffi_zklink_sdk_f180_Deposit_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zklink_sdk_f180_Deposit_object_free.restype = None
_UniFFILib.zklink_sdk_f180_Deposit_new.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Deposit_new.restype = ctypes.c_void_p
_UniFFILib.zklink_sdk_f180_Deposit_get_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Deposit_get_bytes.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_Deposit_tx_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Deposit_tx_hash.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_Deposit_json_str.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Deposit_json_str.restype = RustBuffer
_UniFFILib.ffi_zklink_sdk_f180_Withdraw_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zklink_sdk_f180_Withdraw_object_free.restype = None
_UniFFILib.zklink_sdk_f180_Withdraw_new.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Withdraw_new.restype = ctypes.c_void_p
_UniFFILib.zklink_sdk_f180_Withdraw_get_signature.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Withdraw_get_signature.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_Withdraw_get_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Withdraw_get_bytes.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_Withdraw_tx_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Withdraw_tx_hash.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_Withdraw_json_str.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Withdraw_json_str.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_Withdraw_is_valid.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Withdraw_is_valid.restype = ctypes.c_int8
_UniFFILib.zklink_sdk_f180_Withdraw_is_signature_valid.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Withdraw_is_signature_valid.restype = ctypes.c_int8
_UniFFILib.zklink_sdk_f180_Withdraw_get_eth_sign_msg.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Withdraw_get_eth_sign_msg.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_Withdraw_eth_signature.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Withdraw_eth_signature.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_Withdraw_create_signed_tx.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Withdraw_create_signed_tx.restype = ctypes.c_void_p
_UniFFILib.zklink_sdk_f180_Withdraw_to_zklink_tx.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Withdraw_to_zklink_tx.restype = RustBuffer
_UniFFILib.ffi_zklink_sdk_f180_ChangePubKey_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zklink_sdk_f180_ChangePubKey_object_free.restype = None
_UniFFILib.zklink_sdk_f180_ChangePubKey_new.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_ChangePubKey_new.restype = ctypes.c_void_p
_UniFFILib.zklink_sdk_f180_ChangePubKey_get_signature.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_ChangePubKey_get_signature.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_ChangePubKey_get_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_ChangePubKey_get_bytes.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_ChangePubKey_tx_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_ChangePubKey_tx_hash.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_ChangePubKey_json_str.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_ChangePubKey_json_str.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_ChangePubKey_is_valid.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_ChangePubKey_is_valid.restype = ctypes.c_int8
_UniFFILib.zklink_sdk_f180_ChangePubKey_is_onchain.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_ChangePubKey_is_onchain.restype = ctypes.c_int8
_UniFFILib.zklink_sdk_f180_ChangePubKey_is_signature_valid.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_ChangePubKey_is_signature_valid.restype = ctypes.c_int8
_UniFFILib.zklink_sdk_f180_ChangePubKey_to_zklink_tx.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_ChangePubKey_to_zklink_tx.restype = RustBuffer
_UniFFILib.ffi_zklink_sdk_f180_ForcedExit_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zklink_sdk_f180_ForcedExit_object_free.restype = None
_UniFFILib.zklink_sdk_f180_ForcedExit_new.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_ForcedExit_new.restype = ctypes.c_void_p
_UniFFILib.zklink_sdk_f180_ForcedExit_get_signature.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_ForcedExit_get_signature.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_ForcedExit_get_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_ForcedExit_get_bytes.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_ForcedExit_tx_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_ForcedExit_tx_hash.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_ForcedExit_json_str.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_ForcedExit_json_str.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_ForcedExit_is_valid.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_ForcedExit_is_valid.restype = ctypes.c_int8
_UniFFILib.zklink_sdk_f180_ForcedExit_is_signature_valid.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_ForcedExit_is_signature_valid.restype = ctypes.c_int8
_UniFFILib.zklink_sdk_f180_ForcedExit_create_signed_tx.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_ForcedExit_create_signed_tx.restype = ctypes.c_void_p
_UniFFILib.zklink_sdk_f180_ForcedExit_to_zklink_tx.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_ForcedExit_to_zklink_tx.restype = RustBuffer
_UniFFILib.ffi_zklink_sdk_f180_FullExit_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zklink_sdk_f180_FullExit_object_free.restype = None
_UniFFILib.zklink_sdk_f180_FullExit_new.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_FullExit_new.restype = ctypes.c_void_p
_UniFFILib.zklink_sdk_f180_FullExit_get_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_FullExit_get_bytes.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_FullExit_tx_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_FullExit_tx_hash.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_FullExit_json_str.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_FullExit_json_str.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_FullExit_is_valid.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_FullExit_is_valid.restype = ctypes.c_int8
_UniFFILib.zklink_sdk_f180_FullExit_to_zklink_tx.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_FullExit_to_zklink_tx.restype = RustBuffer
_UniFFILib.ffi_zklink_sdk_f180_Transfer_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zklink_sdk_f180_Transfer_object_free.restype = None
_UniFFILib.zklink_sdk_f180_Transfer_new.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Transfer_new.restype = ctypes.c_void_p
_UniFFILib.zklink_sdk_f180_Transfer_get_signature.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Transfer_get_signature.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_Transfer_get_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Transfer_get_bytes.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_Transfer_tx_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Transfer_tx_hash.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_Transfer_json_str.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Transfer_json_str.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_Transfer_is_valid.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Transfer_is_valid.restype = ctypes.c_int8
_UniFFILib.zklink_sdk_f180_Transfer_is_signature_valid.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Transfer_is_signature_valid.restype = ctypes.c_int8
_UniFFILib.zklink_sdk_f180_Transfer_get_eth_sign_msg.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Transfer_get_eth_sign_msg.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_Transfer_eth_signature.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Transfer_eth_signature.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_Transfer_create_signed_tx.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Transfer_create_signed_tx.restype = ctypes.c_void_p
_UniFFILib.zklink_sdk_f180_Transfer_to_zklink_tx.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Transfer_to_zklink_tx.restype = RustBuffer
_UniFFILib.ffi_zklink_sdk_f180_Order_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zklink_sdk_f180_Order_object_free.restype = None
_UniFFILib.zklink_sdk_f180_Order_new.argtypes = (
    ctypes.c_uint32,
    ctypes.c_uint8,
    ctypes.c_uint32,
    ctypes.c_uint32,
    ctypes.c_uint32,
    ctypes.c_uint32,
    RustBuffer,
    RustBuffer,
    ctypes.c_int8,
    ctypes.c_int8,
    ctypes.c_uint8,
    ctypes.c_uint8,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Order_new.restype = ctypes.c_void_p
_UniFFILib.zklink_sdk_f180_Order_get_signature.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Order_get_signature.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_Order_get_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Order_get_bytes.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_Order_json_str.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Order_json_str.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_Order_is_valid.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Order_is_valid.restype = ctypes.c_int8
_UniFFILib.zklink_sdk_f180_Order_is_signature_valid.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Order_is_signature_valid.restype = ctypes.c_int8
_UniFFILib.zklink_sdk_f180_Order_get_eth_sign_msg.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    ctypes.c_uint8,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Order_get_eth_sign_msg.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_Order_create_signed_order.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Order_create_signed_order.restype = ctypes.c_void_p
_UniFFILib.ffi_zklink_sdk_f180_OrderMatching_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zklink_sdk_f180_OrderMatching_object_free.restype = None
_UniFFILib.zklink_sdk_f180_OrderMatching_new.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_OrderMatching_new.restype = ctypes.c_void_p
_UniFFILib.zklink_sdk_f180_OrderMatching_get_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_OrderMatching_get_bytes.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_OrderMatching_tx_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_OrderMatching_tx_hash.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_OrderMatching_json_str.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_OrderMatching_json_str.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_OrderMatching_is_valid.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_OrderMatching_is_valid.restype = ctypes.c_int8
_UniFFILib.zklink_sdk_f180_OrderMatching_get_signature.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_OrderMatching_get_signature.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_OrderMatching_is_signature_valid.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_OrderMatching_is_signature_valid.restype = ctypes.c_int8
_UniFFILib.zklink_sdk_f180_OrderMatching_create_signed_tx.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_OrderMatching_create_signed_tx.restype = ctypes.c_void_p
_UniFFILib.zklink_sdk_f180_OrderMatching_to_zklink_tx.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_OrderMatching_to_zklink_tx.restype = RustBuffer
_UniFFILib.ffi_zklink_sdk_f180_Contract_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zklink_sdk_f180_Contract_object_free.restype = None
_UniFFILib.zklink_sdk_f180_Contract_new.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Contract_new.restype = ctypes.c_void_p
_UniFFILib.zklink_sdk_f180_Contract_is_long.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Contract_is_long.restype = ctypes.c_int8
_UniFFILib.zklink_sdk_f180_Contract_is_short.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Contract_is_short.restype = ctypes.c_int8
_UniFFILib.zklink_sdk_f180_Contract_get_signature.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Contract_get_signature.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_Contract_is_signature_valid.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Contract_is_signature_valid.restype = ctypes.c_int8
_UniFFILib.zklink_sdk_f180_Contract_get_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Contract_get_bytes.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_Contract_create_signed_contract.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Contract_create_signed_contract.restype = ctypes.c_void_p
_UniFFILib.ffi_zklink_sdk_f180_AutoDeleveraging_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zklink_sdk_f180_AutoDeleveraging_object_free.restype = None
_UniFFILib.zklink_sdk_f180_AutoDeleveraging_new.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_AutoDeleveraging_new.restype = ctypes.c_void_p
_UniFFILib.zklink_sdk_f180_AutoDeleveraging_get_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_AutoDeleveraging_get_bytes.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_AutoDeleveraging_tx_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_AutoDeleveraging_tx_hash.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_AutoDeleveraging_json_str.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_AutoDeleveraging_json_str.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_AutoDeleveraging_is_valid.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_AutoDeleveraging_is_valid.restype = ctypes.c_int8
_UniFFILib.zklink_sdk_f180_AutoDeleveraging_get_signature.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_AutoDeleveraging_get_signature.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_AutoDeleveraging_is_signature_valid.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_AutoDeleveraging_is_signature_valid.restype = ctypes.c_int8
_UniFFILib.zklink_sdk_f180_AutoDeleveraging_to_zklink_tx.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_AutoDeleveraging_to_zklink_tx.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_AutoDeleveraging_create_signed_tx.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_AutoDeleveraging_create_signed_tx.restype = ctypes.c_void_p
_UniFFILib.ffi_zklink_sdk_f180_ContractMatching_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zklink_sdk_f180_ContractMatching_object_free.restype = None
_UniFFILib.zklink_sdk_f180_ContractMatching_new.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_ContractMatching_new.restype = ctypes.c_void_p
_UniFFILib.zklink_sdk_f180_ContractMatching_get_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_ContractMatching_get_bytes.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_ContractMatching_tx_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_ContractMatching_tx_hash.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_ContractMatching_json_str.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_ContractMatching_json_str.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_ContractMatching_is_valid.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_ContractMatching_is_valid.restype = ctypes.c_int8
_UniFFILib.zklink_sdk_f180_ContractMatching_get_signature.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_ContractMatching_get_signature.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_ContractMatching_is_signature_valid.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_ContractMatching_is_signature_valid.restype = ctypes.c_int8
_UniFFILib.zklink_sdk_f180_ContractMatching_to_zklink_tx.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_ContractMatching_to_zklink_tx.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_ContractMatching_create_signed_tx.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_ContractMatching_create_signed_tx.restype = ctypes.c_void_p
_UniFFILib.ffi_zklink_sdk_f180_Funding_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zklink_sdk_f180_Funding_object_free.restype = None
_UniFFILib.zklink_sdk_f180_Funding_new.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Funding_new.restype = ctypes.c_void_p
_UniFFILib.zklink_sdk_f180_Funding_get_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Funding_get_bytes.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_Funding_tx_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Funding_tx_hash.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_Funding_json_str.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Funding_json_str.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_Funding_is_valid.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Funding_is_valid.restype = ctypes.c_int8
_UniFFILib.zklink_sdk_f180_Funding_get_signature.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Funding_get_signature.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_Funding_is_signature_valid.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Funding_is_signature_valid.restype = ctypes.c_int8
_UniFFILib.zklink_sdk_f180_Funding_to_zklink_tx.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Funding_to_zklink_tx.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_Funding_create_signed_tx.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Funding_create_signed_tx.restype = ctypes.c_void_p
_UniFFILib.ffi_zklink_sdk_f180_Liquidation_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zklink_sdk_f180_Liquidation_object_free.restype = None
_UniFFILib.zklink_sdk_f180_Liquidation_new.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Liquidation_new.restype = ctypes.c_void_p
_UniFFILib.zklink_sdk_f180_Liquidation_get_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Liquidation_get_bytes.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_Liquidation_tx_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Liquidation_tx_hash.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_Liquidation_json_str.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Liquidation_json_str.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_Liquidation_is_valid.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Liquidation_is_valid.restype = ctypes.c_int8
_UniFFILib.zklink_sdk_f180_Liquidation_get_signature.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Liquidation_get_signature.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_Liquidation_is_signature_valid.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Liquidation_is_signature_valid.restype = ctypes.c_int8
_UniFFILib.zklink_sdk_f180_Liquidation_to_zklink_tx.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Liquidation_to_zklink_tx.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_Liquidation_create_signed_tx.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Liquidation_create_signed_tx.restype = ctypes.c_void_p
_UniFFILib.ffi_zklink_sdk_f180_UpdateGlobalVar_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zklink_sdk_f180_UpdateGlobalVar_object_free.restype = None
_UniFFILib.zklink_sdk_f180_UpdateGlobalVar_new.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_UpdateGlobalVar_new.restype = ctypes.c_void_p
_UniFFILib.zklink_sdk_f180_UpdateGlobalVar_get_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_UpdateGlobalVar_get_bytes.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_UpdateGlobalVar_tx_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_UpdateGlobalVar_tx_hash.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_UpdateGlobalVar_json_str.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_UpdateGlobalVar_json_str.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_UpdateGlobalVar_is_valid.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_UpdateGlobalVar_is_valid.restype = ctypes.c_int8
_UniFFILib.zklink_sdk_f180_UpdateGlobalVar_to_zklink_tx.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_UpdateGlobalVar_to_zklink_tx.restype = RustBuffer
_UniFFILib.ffi_zklink_sdk_f180_EthSigner_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zklink_sdk_f180_EthSigner_object_free.restype = None
_UniFFILib.zklink_sdk_f180_EthSigner_new.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_EthSigner_new.restype = ctypes.c_void_p
_UniFFILib.zklink_sdk_f180_EthSigner_sign_message.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_EthSigner_sign_message.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_EthSigner_get_address.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_EthSigner_get_address.restype = RustBuffer
_UniFFILib.ffi_zklink_sdk_f180_TypedData_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zklink_sdk_f180_TypedData_object_free.restype = None
_UniFFILib.zklink_sdk_f180_TypedData_new.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_TypedData_new.restype = ctypes.c_void_p
_UniFFILib.ffi_zklink_sdk_f180_StarkSigner_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zklink_sdk_f180_StarkSigner_object_free.restype = None
_UniFFILib.zklink_sdk_f180_StarkSigner_new.argtypes = (
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_StarkSigner_new.restype = ctypes.c_void_p
_UniFFILib.zklink_sdk_f180_StarkSigner_new_from_hex_str.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_StarkSigner_new_from_hex_str.restype = ctypes.c_void_p
_UniFFILib.zklink_sdk_f180_StarkSigner_sign_message.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_StarkSigner_sign_message.restype = RustBuffer
_UniFFILib.ffi_zklink_sdk_f180_ZkLinkSigner_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zklink_sdk_f180_ZkLinkSigner_object_free.restype = None
_UniFFILib.zklink_sdk_f180_ZkLinkSigner_new.argtypes = (
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_ZkLinkSigner_new.restype = ctypes.c_void_p
_UniFFILib.zklink_sdk_f180_ZkLinkSigner_new_from_seed.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_ZkLinkSigner_new_from_seed.restype = ctypes.c_void_p
_UniFFILib.zklink_sdk_f180_ZkLinkSigner_new_from_hex_eth_signer.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_ZkLinkSigner_new_from_hex_eth_signer.restype = ctypes.c_void_p
_UniFFILib.zklink_sdk_f180_ZkLinkSigner_new_from_hex_stark_signer.argtypes = (
    RustBuffer,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_ZkLinkSigner_new_from_hex_stark_signer.restype = ctypes.c_void_p
_UniFFILib.zklink_sdk_f180_ZkLinkSigner_new_from_bytes.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_ZkLinkSigner_new_from_bytes.restype = ctypes.c_void_p
_UniFFILib.zklink_sdk_f180_ZkLinkSigner_public_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_ZkLinkSigner_public_key.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_ZkLinkSigner_sign_musig.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_ZkLinkSigner_sign_musig.restype = RustBuffer
_UniFFILib.ffi_zklink_sdk_f180_Signer_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zklink_sdk_f180_Signer_object_free.restype = None
_UniFFILib.zklink_sdk_f180_Signer_new.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Signer_new.restype = ctypes.c_void_p
_UniFFILib.zklink_sdk_f180_Signer_sign_change_pubkey_with_create2data_auth.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Signer_sign_change_pubkey_with_create2data_auth.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_Signer_sign_change_pubkey_with_onchain_auth_data.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Signer_sign_change_pubkey_with_onchain_auth_data.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_Signer_sign_change_pubkey_with_eth_ecdsa_auth.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Signer_sign_change_pubkey_with_eth_ecdsa_auth.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_Signer_sign_transfer.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Signer_sign_transfer.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_Signer_sign_withdraw.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Signer_sign_withdraw.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_Signer_sign_forced_exit.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Signer_sign_forced_exit.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_Signer_sign_order_matching.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Signer_sign_order_matching.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_Signer_sign_contract_matching.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Signer_sign_contract_matching.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_Signer_sign_funding.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Signer_sign_funding.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_Signer_sign_liquidation.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Signer_sign_liquidation.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_Signer_sign_auto_deleveraging.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_Signer_sign_auto_deleveraging.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_verify_musig.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_verify_musig.restype = ctypes.c_int8
_UniFFILib.zklink_sdk_f180_get_public_key_hash.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_get_public_key_hash.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_zklink_main_net_url.argtypes = (
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_zklink_main_net_url.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_zklink_test_net_url.argtypes = (
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_zklink_test_net_url.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_eth_signature_of_change_pubkey.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_eth_signature_of_change_pubkey.restype = RustBuffer
_UniFFILib.zklink_sdk_f180_create_signed_change_pubkey.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.zklink_sdk_f180_create_signed_change_pubkey.restype = ctypes.c_void_p
_UniFFILib.ffi_zklink_sdk_f180_rustbuffer_alloc.argtypes = (
    ctypes.c_int32,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zklink_sdk_f180_rustbuffer_alloc.restype = RustBuffer
_UniFFILib.ffi_zklink_sdk_f180_rustbuffer_from_bytes.argtypes = (
    ForeignBytes,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zklink_sdk_f180_rustbuffer_from_bytes.restype = RustBuffer
_UniFFILib.ffi_zklink_sdk_f180_rustbuffer_free.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zklink_sdk_f180_rustbuffer_free.restype = None
_UniFFILib.ffi_zklink_sdk_f180_rustbuffer_reserve.argtypes = (
    RustBuffer,
    ctypes.c_int32,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_zklink_sdk_f180_rustbuffer_reserve.restype = RustBuffer

# Public interface members begin here.


class FfiConverterUInt8(FfiConverterPrimitive):
    @staticmethod
    def read(buf):
        return buf.readU8()

    @staticmethod
    def write(value, buf):
        buf.writeU8(value)

class FfiConverterUInt16(FfiConverterPrimitive):
    @staticmethod
    def read(buf):
        return buf.readU16()

    @staticmethod
    def write(value, buf):
        buf.writeU16(value)

class FfiConverterInt16(FfiConverterPrimitive):
    @staticmethod
    def read(buf):
        return buf.readI16()

    @staticmethod
    def write(value, buf):
        buf.writeI16(value)

class FfiConverterUInt32(FfiConverterPrimitive):
    @staticmethod
    def read(buf):
        return buf.readU32()

    @staticmethod
    def write(value, buf):
        buf.writeU32(value)

class FfiConverterUInt64(FfiConverterPrimitive):
    @staticmethod
    def read(buf):
        return buf.readU64()

    @staticmethod
    def write(value, buf):
        buf.writeU64(value)

class FfiConverterBool:
    @classmethod
    def read(cls, buf):
        return cls.lift(buf.readU8())

    @classmethod
    def write(cls, value, buf):
        buf.writeU8(cls.lower(value))

    @staticmethod
    def lift(value):
        return int(value) != 0

    @staticmethod
    def lower(value):
        return 1 if value else 0

class FfiConverterString:
    @staticmethod
    def read(buf):
        size = buf.readI32()
        if size < 0:
            raise InternalError("Unexpected negative string length")
        utf8Bytes = buf.read(size)
        return utf8Bytes.decode("utf-8")

    @staticmethod
    def write(value, buf):
        utf8Bytes = value.encode("utf-8")
        buf.writeI32(len(utf8Bytes))
        buf.write(utf8Bytes)

    @staticmethod
    def lift(buf):
        with buf.consumeWithStream() as stream:
            return stream.read(stream.remaining()).decode("utf-8")

    @staticmethod
    def lower(value):
        with RustBuffer.allocWithBuilder() as builder:
            builder.write(value.encode("utf-8"))
            return builder.finalize()



class AutoDeleveraging(object):
    def __init__(self, builder):
        builder = builder
        
        self._pointer = rust_call(_UniFFILib.zklink_sdk_f180_AutoDeleveraging_new,
        FfiConverterTypeAutoDeleveragingBuilder.lower(builder))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zklink_sdk_f180_AutoDeleveraging_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def get_bytes(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_AutoDeleveraging_get_bytes,self._pointer,)
        )
    def tx_hash(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_AutoDeleveraging_tx_hash,self._pointer,)
        )
    def json_str(self, ):
        return FfiConverterString.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_AutoDeleveraging_json_str,self._pointer,)
        )
    def is_valid(self, ):
        return FfiConverterBool.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_AutoDeleveraging_is_valid,self._pointer,)
        )
    def get_signature(self, ):
        return FfiConverterTypeZkLinkSignature.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_AutoDeleveraging_get_signature,self._pointer,)
        )
    def is_signature_valid(self, ):
        return FfiConverterBool.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_AutoDeleveraging_is_signature_valid,self._pointer,)
        )
    def to_zklink_tx(self, ):
        return FfiConverterTypeZkLinkTx.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_AutoDeleveraging_to_zklink_tx,self._pointer,)
        )
    def create_signed_tx(self, signer):
        signer = signer
        
        return FfiConverterTypeAutoDeleveraging.lift(
            rust_call_with_error(
    FfiConverterTypeZkSignerError,_UniFFILib.zklink_sdk_f180_AutoDeleveraging_create_signed_tx,self._pointer,
        FfiConverterTypeZkLinkSigner.lower(signer))
        )
    


class FfiConverterTypeAutoDeleveraging:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, AutoDeleveraging):
            raise TypeError("Expected AutoDeleveraging instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return AutoDeleveraging._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ChangePubKey(object):
    def __init__(self, builder):
        builder = builder
        
        self._pointer = rust_call(_UniFFILib.zklink_sdk_f180_ChangePubKey_new,
        FfiConverterTypeChangePubKeyBuilder.lower(builder))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zklink_sdk_f180_ChangePubKey_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def get_signature(self, ):
        return FfiConverterTypeZkLinkSignature.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_ChangePubKey_get_signature,self._pointer,)
        )
    def get_bytes(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_ChangePubKey_get_bytes,self._pointer,)
        )
    def tx_hash(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_ChangePubKey_tx_hash,self._pointer,)
        )
    def json_str(self, ):
        return FfiConverterString.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_ChangePubKey_json_str,self._pointer,)
        )
    def is_valid(self, ):
        return FfiConverterBool.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_ChangePubKey_is_valid,self._pointer,)
        )
    def is_onchain(self, ):
        return FfiConverterBool.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_ChangePubKey_is_onchain,self._pointer,)
        )
    def is_signature_valid(self, ):
        return FfiConverterBool.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_ChangePubKey_is_signature_valid,self._pointer,)
        )
    def to_zklink_tx(self, ):
        return FfiConverterTypeZkLinkTx.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_ChangePubKey_to_zklink_tx,self._pointer,)
        )
    


class FfiConverterTypeChangePubKey:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ChangePubKey):
            raise TypeError("Expected ChangePubKey instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ChangePubKey._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class Contract(object):
    def __init__(self, builder):
        builder = builder
        
        self._pointer = rust_call(_UniFFILib.zklink_sdk_f180_Contract_new,
        FfiConverterTypeContractBuilder.lower(builder))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zklink_sdk_f180_Contract_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def is_long(self, ):
        return FfiConverterBool.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_Contract_is_long,self._pointer,)
        )
    def is_short(self, ):
        return FfiConverterBool.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_Contract_is_short,self._pointer,)
        )
    def get_signature(self, ):
        return FfiConverterTypeZkLinkSignature.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_Contract_get_signature,self._pointer,)
        )
    def is_signature_valid(self, ):
        return FfiConverterBool.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_Contract_is_signature_valid,self._pointer,)
        )
    def get_bytes(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_Contract_get_bytes,self._pointer,)
        )
    def create_signed_contract(self, zklink_signer):
        zklink_signer = zklink_signer
        
        return FfiConverterTypeContract.lift(
            rust_call_with_error(
    FfiConverterTypeZkSignerError,_UniFFILib.zklink_sdk_f180_Contract_create_signed_contract,self._pointer,
        FfiConverterTypeZkLinkSigner.lower(zklink_signer))
        )
    


class FfiConverterTypeContract:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, Contract):
            raise TypeError("Expected Contract instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return Contract._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ContractMatching(object):
    def __init__(self, builder):
        builder = builder
        
        self._pointer = rust_call(_UniFFILib.zklink_sdk_f180_ContractMatching_new,
        FfiConverterTypeContractMatchingBuilder.lower(builder))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zklink_sdk_f180_ContractMatching_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def get_bytes(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_ContractMatching_get_bytes,self._pointer,)
        )
    def tx_hash(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_ContractMatching_tx_hash,self._pointer,)
        )
    def json_str(self, ):
        return FfiConverterString.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_ContractMatching_json_str,self._pointer,)
        )
    def is_valid(self, ):
        return FfiConverterBool.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_ContractMatching_is_valid,self._pointer,)
        )
    def get_signature(self, ):
        return FfiConverterTypeZkLinkSignature.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_ContractMatching_get_signature,self._pointer,)
        )
    def is_signature_valid(self, ):
        return FfiConverterBool.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_ContractMatching_is_signature_valid,self._pointer,)
        )
    def to_zklink_tx(self, ):
        return FfiConverterTypeZkLinkTx.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_ContractMatching_to_zklink_tx,self._pointer,)
        )
    def create_signed_tx(self, signer):
        signer = signer
        
        return FfiConverterTypeContractMatching.lift(
            rust_call_with_error(
    FfiConverterTypeZkSignerError,_UniFFILib.zklink_sdk_f180_ContractMatching_create_signed_tx,self._pointer,
        FfiConverterTypeZkLinkSigner.lower(signer))
        )
    


class FfiConverterTypeContractMatching:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ContractMatching):
            raise TypeError("Expected ContractMatching instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ContractMatching._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class Deposit(object):
    def __init__(self, builder):
        builder = builder
        
        self._pointer = rust_call(_UniFFILib.zklink_sdk_f180_Deposit_new,
        FfiConverterTypeDepositBuilder.lower(builder))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zklink_sdk_f180_Deposit_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def get_bytes(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_Deposit_get_bytes,self._pointer,)
        )
    def tx_hash(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_Deposit_tx_hash,self._pointer,)
        )
    def json_str(self, ):
        return FfiConverterString.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_Deposit_json_str,self._pointer,)
        )
    


class FfiConverterTypeDeposit:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, Deposit):
            raise TypeError("Expected Deposit instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return Deposit._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class EthSigner(object):
    def __init__(self, private_key):
        private_key = private_key
        
        self._pointer = rust_call_with_error(FfiConverterTypeEthSignerError,_UniFFILib.zklink_sdk_f180_EthSigner_new,
        FfiConverterString.lower(private_key))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zklink_sdk_f180_EthSigner_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def sign_message(self, message):
        message = list(int(x) for x in message)
        
        return FfiConverterTypePackedEthSignature.lift(
            rust_call_with_error(
    FfiConverterTypeEthSignerError,_UniFFILib.zklink_sdk_f180_EthSigner_sign_message,self._pointer,
        FfiConverterSequenceUInt8.lower(message))
        )
    def get_address(self, ):
        return FfiConverterTypeAddress.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_EthSigner_get_address,self._pointer,)
        )
    


class FfiConverterTypeEthSigner:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, EthSigner):
            raise TypeError("Expected EthSigner instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return EthSigner._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ForcedExit(object):
    def __init__(self, builder):
        builder = builder
        
        self._pointer = rust_call(_UniFFILib.zklink_sdk_f180_ForcedExit_new,
        FfiConverterTypeForcedExitBuilder.lower(builder))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zklink_sdk_f180_ForcedExit_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def get_signature(self, ):
        return FfiConverterTypeZkLinkSignature.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_ForcedExit_get_signature,self._pointer,)
        )
    def get_bytes(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_ForcedExit_get_bytes,self._pointer,)
        )
    def tx_hash(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_ForcedExit_tx_hash,self._pointer,)
        )
    def json_str(self, ):
        return FfiConverterString.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_ForcedExit_json_str,self._pointer,)
        )
    def is_valid(self, ):
        return FfiConverterBool.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_ForcedExit_is_valid,self._pointer,)
        )
    def is_signature_valid(self, ):
        return FfiConverterBool.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_ForcedExit_is_signature_valid,self._pointer,)
        )
    def create_signed_tx(self, signer):
        signer = signer
        
        return FfiConverterTypeForcedExit.lift(
            rust_call_with_error(
    FfiConverterTypeZkSignerError,_UniFFILib.zklink_sdk_f180_ForcedExit_create_signed_tx,self._pointer,
        FfiConverterTypeZkLinkSigner.lower(signer))
        )
    def to_zklink_tx(self, ):
        return FfiConverterTypeZkLinkTx.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_ForcedExit_to_zklink_tx,self._pointer,)
        )
    


class FfiConverterTypeForcedExit:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ForcedExit):
            raise TypeError("Expected ForcedExit instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ForcedExit._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class FullExit(object):
    def __init__(self, builder):
        builder = builder
        
        self._pointer = rust_call(_UniFFILib.zklink_sdk_f180_FullExit_new,
        FfiConverterTypeFullExitBuilder.lower(builder))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zklink_sdk_f180_FullExit_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def get_bytes(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_FullExit_get_bytes,self._pointer,)
        )
    def tx_hash(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_FullExit_tx_hash,self._pointer,)
        )
    def json_str(self, ):
        return FfiConverterString.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_FullExit_json_str,self._pointer,)
        )
    def is_valid(self, ):
        return FfiConverterBool.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_FullExit_is_valid,self._pointer,)
        )
    def to_zklink_tx(self, ):
        return FfiConverterTypeZkLinkTx.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_FullExit_to_zklink_tx,self._pointer,)
        )
    


class FfiConverterTypeFullExit:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, FullExit):
            raise TypeError("Expected FullExit instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return FullExit._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class Funding(object):
    def __init__(self, builder):
        builder = builder
        
        self._pointer = rust_call(_UniFFILib.zklink_sdk_f180_Funding_new,
        FfiConverterTypeFundingBuilder.lower(builder))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zklink_sdk_f180_Funding_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def get_bytes(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_Funding_get_bytes,self._pointer,)
        )
    def tx_hash(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_Funding_tx_hash,self._pointer,)
        )
    def json_str(self, ):
        return FfiConverterString.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_Funding_json_str,self._pointer,)
        )
    def is_valid(self, ):
        return FfiConverterBool.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_Funding_is_valid,self._pointer,)
        )
    def get_signature(self, ):
        return FfiConverterTypeZkLinkSignature.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_Funding_get_signature,self._pointer,)
        )
    def is_signature_valid(self, ):
        return FfiConverterBool.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_Funding_is_signature_valid,self._pointer,)
        )
    def to_zklink_tx(self, ):
        return FfiConverterTypeZkLinkTx.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_Funding_to_zklink_tx,self._pointer,)
        )
    def create_signed_tx(self, signer):
        signer = signer
        
        return FfiConverterTypeFunding.lift(
            rust_call_with_error(
    FfiConverterTypeZkSignerError,_UniFFILib.zklink_sdk_f180_Funding_create_signed_tx,self._pointer,
        FfiConverterTypeZkLinkSigner.lower(signer))
        )
    


class FfiConverterTypeFunding:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, Funding):
            raise TypeError("Expected Funding instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return Funding._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class Liquidation(object):
    def __init__(self, builder):
        builder = builder
        
        self._pointer = rust_call(_UniFFILib.zklink_sdk_f180_Liquidation_new,
        FfiConverterTypeLiquidationBuilder.lower(builder))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zklink_sdk_f180_Liquidation_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def get_bytes(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_Liquidation_get_bytes,self._pointer,)
        )
    def tx_hash(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_Liquidation_tx_hash,self._pointer,)
        )
    def json_str(self, ):
        return FfiConverterString.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_Liquidation_json_str,self._pointer,)
        )
    def is_valid(self, ):
        return FfiConverterBool.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_Liquidation_is_valid,self._pointer,)
        )
    def get_signature(self, ):
        return FfiConverterTypeZkLinkSignature.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_Liquidation_get_signature,self._pointer,)
        )
    def is_signature_valid(self, ):
        return FfiConverterBool.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_Liquidation_is_signature_valid,self._pointer,)
        )
    def to_zklink_tx(self, ):
        return FfiConverterTypeZkLinkTx.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_Liquidation_to_zklink_tx,self._pointer,)
        )
    def create_signed_tx(self, signer):
        signer = signer
        
        return FfiConverterTypeLiquidation.lift(
            rust_call_with_error(
    FfiConverterTypeZkSignerError,_UniFFILib.zklink_sdk_f180_Liquidation_create_signed_tx,self._pointer,
        FfiConverterTypeZkLinkSigner.lower(signer))
        )
    


class FfiConverterTypeLiquidation:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, Liquidation):
            raise TypeError("Expected Liquidation instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return Liquidation._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class Order(object):
    def __init__(self, account_id,sub_account_id,slot_id,nonce,base_token_id,quote_token_id,amount,price,is_sell,has_subsidy,maker_fee_rate,taker_fee_rate,signature):
        account_id = account_id
        
        sub_account_id = sub_account_id
        
        slot_id = slot_id
        
        nonce = nonce
        
        base_token_id = base_token_id
        
        quote_token_id = quote_token_id
        
        amount = amount
        
        price = price
        
        is_sell = bool(is_sell)
        
        has_subsidy = bool(has_subsidy)
        
        maker_fee_rate = int(maker_fee_rate)
        
        taker_fee_rate = int(taker_fee_rate)
        
        signature = (None if signature is None else signature)
        
        self._pointer = rust_call(_UniFFILib.zklink_sdk_f180_Order_new,
        FfiConverterTypeAccountId.lower(account_id),
        FfiConverterTypeSubAccountId.lower(sub_account_id),
        FfiConverterTypeSlotId.lower(slot_id),
        FfiConverterTypeNonce.lower(nonce),
        FfiConverterTypeTokenId.lower(base_token_id),
        FfiConverterTypeTokenId.lower(quote_token_id),
        FfiConverterTypeBigUint.lower(amount),
        FfiConverterTypeBigUint.lower(price),
        FfiConverterBool.lower(is_sell),
        FfiConverterBool.lower(has_subsidy),
        FfiConverterUInt8.lower(maker_fee_rate),
        FfiConverterUInt8.lower(taker_fee_rate),
        FfiConverterOptionalTypeZkLinkSignature.lower(signature))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zklink_sdk_f180_Order_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def get_signature(self, ):
        return FfiConverterTypeZkLinkSignature.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_Order_get_signature,self._pointer,)
        )
    def get_bytes(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_Order_get_bytes,self._pointer,)
        )
    def json_str(self, ):
        return FfiConverterString.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_Order_json_str,self._pointer,)
        )
    def is_valid(self, ):
        return FfiConverterBool.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_Order_is_valid,self._pointer,)
        )
    def is_signature_valid(self, ):
        return FfiConverterBool.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_Order_is_signature_valid,self._pointer,)
        )
    def get_eth_sign_msg(self, quote_token,based_token,decimals):
        quote_token = quote_token
        
        based_token = based_token
        
        decimals = int(decimals)
        
        return FfiConverterString.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_Order_get_eth_sign_msg,self._pointer,
        FfiConverterString.lower(quote_token),
        FfiConverterString.lower(based_token),
        FfiConverterUInt8.lower(decimals))
        )
    def create_signed_order(self, zklink_signer):
        zklink_signer = zklink_signer
        
        return FfiConverterTypeOrder.lift(
            rust_call_with_error(
    FfiConverterTypeZkSignerError,_UniFFILib.zklink_sdk_f180_Order_create_signed_order,self._pointer,
        FfiConverterTypeZkLinkSigner.lower(zklink_signer))
        )
    


class FfiConverterTypeOrder:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, Order):
            raise TypeError("Expected Order instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return Order._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class OrderMatching(object):
    def __init__(self, builder):
        builder = builder
        
        self._pointer = rust_call(_UniFFILib.zklink_sdk_f180_OrderMatching_new,
        FfiConverterTypeOrderMatchingBuilder.lower(builder))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zklink_sdk_f180_OrderMatching_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def get_bytes(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_OrderMatching_get_bytes,self._pointer,)
        )
    def tx_hash(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_OrderMatching_tx_hash,self._pointer,)
        )
    def json_str(self, ):
        return FfiConverterString.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_OrderMatching_json_str,self._pointer,)
        )
    def is_valid(self, ):
        return FfiConverterBool.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_OrderMatching_is_valid,self._pointer,)
        )
    def get_signature(self, ):
        return FfiConverterTypeZkLinkSignature.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_OrderMatching_get_signature,self._pointer,)
        )
    def is_signature_valid(self, ):
        return FfiConverterBool.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_OrderMatching_is_signature_valid,self._pointer,)
        )
    def create_signed_tx(self, signer):
        signer = signer
        
        return FfiConverterTypeOrderMatching.lift(
            rust_call_with_error(
    FfiConverterTypeZkSignerError,_UniFFILib.zklink_sdk_f180_OrderMatching_create_signed_tx,self._pointer,
        FfiConverterTypeZkLinkSigner.lower(signer))
        )
    def to_zklink_tx(self, ):
        return FfiConverterTypeZkLinkTx.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_OrderMatching_to_zklink_tx,self._pointer,)
        )
    


class FfiConverterTypeOrderMatching:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, OrderMatching):
            raise TypeError("Expected OrderMatching instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return OrderMatching._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class Signer(object):
    def __init__(self, private_key,l1_type):
        private_key = private_key
        
        l1_type = l1_type
        
        self._pointer = rust_call_with_error(FfiConverterTypeSignError,_UniFFILib.zklink_sdk_f180_Signer_new,
        FfiConverterString.lower(private_key),
        FfiConverterTypeL1SignerType.lower(l1_type))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zklink_sdk_f180_Signer_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def sign_change_pubkey_with_create2data_auth(self, tx,crate2data):
        tx = tx
        
        crate2data = crate2data
        
        return FfiConverterTypeTxSignature.lift(
            rust_call_with_error(
    FfiConverterTypeSignError,_UniFFILib.zklink_sdk_f180_Signer_sign_change_pubkey_with_create2data_auth,self._pointer,
        FfiConverterTypeChangePubKey.lower(tx),
        FfiConverterTypeCreate2Data.lower(crate2data))
        )
    def sign_change_pubkey_with_onchain_auth_data(self, tx):
        tx = tx
        
        return FfiConverterTypeTxSignature.lift(
            rust_call_with_error(
    FfiConverterTypeSignError,_UniFFILib.zklink_sdk_f180_Signer_sign_change_pubkey_with_onchain_auth_data,self._pointer,
        FfiConverterTypeChangePubKey.lower(tx))
        )
    def sign_change_pubkey_with_eth_ecdsa_auth(self, tx):
        tx = tx
        
        return FfiConverterTypeTxSignature.lift(
            rust_call_with_error(
    FfiConverterTypeSignError,_UniFFILib.zklink_sdk_f180_Signer_sign_change_pubkey_with_eth_ecdsa_auth,self._pointer,
        FfiConverterTypeChangePubKey.lower(tx))
        )
    def sign_transfer(self, tx,token_sybmol,chain_id,addr):
        tx = tx
        
        token_sybmol = token_sybmol
        
        chain_id = (None if chain_id is None else chain_id)
        
        addr = (None if addr is None else addr)
        
        return FfiConverterTypeTxSignature.lift(
            rust_call_with_error(
    FfiConverterTypeSignError,_UniFFILib.zklink_sdk_f180_Signer_sign_transfer,self._pointer,
        FfiConverterTypeTransfer.lower(tx),
        FfiConverterString.lower(token_sybmol),
        FfiConverterOptionalString.lower(chain_id),
        FfiConverterOptionalString.lower(addr))
        )
    def sign_withdraw(self, tx,l2_source_token_symbol,chain_id,addr):
        tx = tx
        
        l2_source_token_symbol = l2_source_token_symbol
        
        chain_id = (None if chain_id is None else chain_id)
        
        addr = (None if addr is None else addr)
        
        return FfiConverterTypeTxSignature.lift(
            rust_call_with_error(
    FfiConverterTypeSignError,_UniFFILib.zklink_sdk_f180_Signer_sign_withdraw,self._pointer,
        FfiConverterTypeWithdraw.lower(tx),
        FfiConverterString.lower(l2_source_token_symbol),
        FfiConverterOptionalString.lower(chain_id),
        FfiConverterOptionalString.lower(addr))
        )
    def sign_forced_exit(self, tx):
        tx = tx
        
        return FfiConverterTypeTxSignature.lift(
            rust_call_with_error(
    FfiConverterTypeSignError,_UniFFILib.zklink_sdk_f180_Signer_sign_forced_exit,self._pointer,
        FfiConverterTypeForcedExit.lower(tx))
        )
    def sign_order_matching(self, tx):
        tx = tx
        
        return FfiConverterTypeTxSignature.lift(
            rust_call_with_error(
    FfiConverterTypeSignError,_UniFFILib.zklink_sdk_f180_Signer_sign_order_matching,self._pointer,
        FfiConverterTypeOrderMatching.lower(tx))
        )
    def sign_contract_matching(self, tx):
        tx = tx
        
        return FfiConverterTypeTxSignature.lift(
            rust_call_with_error(
    FfiConverterTypeSignError,_UniFFILib.zklink_sdk_f180_Signer_sign_contract_matching,self._pointer,
        FfiConverterTypeContractMatching.lower(tx))
        )
    def sign_funding(self, tx):
        tx = tx
        
        return FfiConverterTypeTxSignature.lift(
            rust_call_with_error(
    FfiConverterTypeSignError,_UniFFILib.zklink_sdk_f180_Signer_sign_funding,self._pointer,
        FfiConverterTypeFunding.lower(tx))
        )
    def sign_liquidation(self, tx):
        tx = tx
        
        return FfiConverterTypeTxSignature.lift(
            rust_call_with_error(
    FfiConverterTypeSignError,_UniFFILib.zklink_sdk_f180_Signer_sign_liquidation,self._pointer,
        FfiConverterTypeLiquidation.lower(tx))
        )
    def sign_auto_deleveraging(self, tx):
        tx = tx
        
        return FfiConverterTypeTxSignature.lift(
            rust_call_with_error(
    FfiConverterTypeSignError,_UniFFILib.zklink_sdk_f180_Signer_sign_auto_deleveraging,self._pointer,
        FfiConverterTypeAutoDeleveraging.lower(tx))
        )
    


class FfiConverterTypeSigner:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, Signer):
            raise TypeError("Expected Signer instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return Signer._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class StarkSigner(object):
    def __init__(self, ):
        self._pointer = rust_call(_UniFFILib.zklink_sdk_f180_StarkSigner_new,)

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zklink_sdk_f180_StarkSigner_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def new_from_hex_str(cls, hex_str):
        hex_str = hex_str
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeStarkSignerError,_UniFFILib.zklink_sdk_f180_StarkSigner_new_from_hex_str,
        FfiConverterString.lower(hex_str))
        return cls._make_instance_(pointer)
    

    def sign_message(self, typed_data,addr):
        typed_data = typed_data
        
        addr = addr
        
        return FfiConverterTypeStarkEip712Signature.lift(
            rust_call_with_error(
    FfiConverterTypeStarkSignerError,_UniFFILib.zklink_sdk_f180_StarkSigner_sign_message,self._pointer,
        FfiConverterTypeTypedData.lower(typed_data),
        FfiConverterString.lower(addr))
        )
    


class FfiConverterTypeStarkSigner:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, StarkSigner):
            raise TypeError("Expected StarkSigner instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return StarkSigner._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class Transfer(object):
    def __init__(self, builder):
        builder = builder
        
        self._pointer = rust_call(_UniFFILib.zklink_sdk_f180_Transfer_new,
        FfiConverterTypeTransferBuilder.lower(builder))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zklink_sdk_f180_Transfer_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def get_signature(self, ):
        return FfiConverterTypeZkLinkSignature.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_Transfer_get_signature,self._pointer,)
        )
    def get_bytes(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_Transfer_get_bytes,self._pointer,)
        )
    def tx_hash(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_Transfer_tx_hash,self._pointer,)
        )
    def json_str(self, ):
        return FfiConverterString.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_Transfer_json_str,self._pointer,)
        )
    def is_valid(self, ):
        return FfiConverterBool.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_Transfer_is_valid,self._pointer,)
        )
    def is_signature_valid(self, ):
        return FfiConverterBool.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_Transfer_is_signature_valid,self._pointer,)
        )
    def get_eth_sign_msg(self, token_symbol):
        token_symbol = token_symbol
        
        return FfiConverterString.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_Transfer_get_eth_sign_msg,self._pointer,
        FfiConverterString.lower(token_symbol))
        )
    def eth_signature(self, eth_signer,token_symbol):
        eth_signer = eth_signer
        
        token_symbol = token_symbol
        
        return FfiConverterTypeTxLayer1Signature.lift(
            rust_call_with_error(
    FfiConverterTypeZkSignerError,_UniFFILib.zklink_sdk_f180_Transfer_eth_signature,self._pointer,
        FfiConverterTypeEthSigner.lower(eth_signer),
        FfiConverterString.lower(token_symbol))
        )
    def create_signed_tx(self, signer):
        signer = signer
        
        return FfiConverterTypeTransfer.lift(
            rust_call_with_error(
    FfiConverterTypeZkSignerError,_UniFFILib.zklink_sdk_f180_Transfer_create_signed_tx,self._pointer,
        FfiConverterTypeZkLinkSigner.lower(signer))
        )
    def to_zklink_tx(self, ):
        return FfiConverterTypeZkLinkTx.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_Transfer_to_zklink_tx,self._pointer,)
        )
    


class FfiConverterTypeTransfer:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, Transfer):
            raise TypeError("Expected Transfer instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return Transfer._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class TypedData(object):
    def __init__(self, message,chain_id):
        message = message
        
        chain_id = chain_id
        
        self._pointer = rust_call(_UniFFILib.zklink_sdk_f180_TypedData_new,
        FfiConverterTypeTypedDataMessage.lower(message),
        FfiConverterString.lower(chain_id))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zklink_sdk_f180_TypedData_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    


class FfiConverterTypeTypedData:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, TypedData):
            raise TypeError("Expected TypedData instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return TypedData._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class UpdateGlobalVar(object):
    def __init__(self, builder):
        builder = builder
        
        self._pointer = rust_call(_UniFFILib.zklink_sdk_f180_UpdateGlobalVar_new,
        FfiConverterTypeUpdateGlobalVarBuilder.lower(builder))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zklink_sdk_f180_UpdateGlobalVar_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def get_bytes(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_UpdateGlobalVar_get_bytes,self._pointer,)
        )
    def tx_hash(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_UpdateGlobalVar_tx_hash,self._pointer,)
        )
    def json_str(self, ):
        return FfiConverterString.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_UpdateGlobalVar_json_str,self._pointer,)
        )
    def is_valid(self, ):
        return FfiConverterBool.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_UpdateGlobalVar_is_valid,self._pointer,)
        )
    def to_zklink_tx(self, ):
        return FfiConverterTypeZkLinkTx.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_UpdateGlobalVar_to_zklink_tx,self._pointer,)
        )
    


class FfiConverterTypeUpdateGlobalVar:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, UpdateGlobalVar):
            raise TypeError("Expected UpdateGlobalVar instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return UpdateGlobalVar._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class Withdraw(object):
    def __init__(self, builder):
        builder = builder
        
        self._pointer = rust_call(_UniFFILib.zklink_sdk_f180_Withdraw_new,
        FfiConverterTypeWithdrawBuilder.lower(builder))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zklink_sdk_f180_Withdraw_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def get_signature(self, ):
        return FfiConverterTypeZkLinkSignature.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_Withdraw_get_signature,self._pointer,)
        )
    def get_bytes(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_Withdraw_get_bytes,self._pointer,)
        )
    def tx_hash(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_Withdraw_tx_hash,self._pointer,)
        )
    def json_str(self, ):
        return FfiConverterString.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_Withdraw_json_str,self._pointer,)
        )
    def is_valid(self, ):
        return FfiConverterBool.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_Withdraw_is_valid,self._pointer,)
        )
    def is_signature_valid(self, ):
        return FfiConverterBool.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_Withdraw_is_signature_valid,self._pointer,)
        )
    def get_eth_sign_msg(self, token_symbol):
        token_symbol = token_symbol
        
        return FfiConverterString.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_Withdraw_get_eth_sign_msg,self._pointer,
        FfiConverterString.lower(token_symbol))
        )
    def eth_signature(self, eth_signer,l2_source_token_symbol):
        eth_signer = eth_signer
        
        l2_source_token_symbol = l2_source_token_symbol
        
        return FfiConverterTypePackedEthSignature.lift(
            rust_call_with_error(
    FfiConverterTypeZkSignerError,_UniFFILib.zklink_sdk_f180_Withdraw_eth_signature,self._pointer,
        FfiConverterTypeEthSigner.lower(eth_signer),
        FfiConverterString.lower(l2_source_token_symbol))
        )
    def create_signed_tx(self, signer):
        signer = signer
        
        return FfiConverterTypeWithdraw.lift(
            rust_call_with_error(
    FfiConverterTypeZkSignerError,_UniFFILib.zklink_sdk_f180_Withdraw_create_signed_tx,self._pointer,
        FfiConverterTypeZkLinkSigner.lower(signer))
        )
    def to_zklink_tx(self, ):
        return FfiConverterTypeZkLinkTx.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_Withdraw_to_zklink_tx,self._pointer,)
        )
    


class FfiConverterTypeWithdraw:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, Withdraw):
            raise TypeError("Expected Withdraw instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return Withdraw._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ZkLinkSigner(object):
    def __init__(self, ):
        self._pointer = rust_call_with_error(FfiConverterTypeZkSignerError,_UniFFILib.zklink_sdk_f180_ZkLinkSigner_new,)

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_zklink_sdk_f180_ZkLinkSigner_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def new_from_seed(cls, seed):
        seed = list(int(x) for x in seed)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeZkSignerError,_UniFFILib.zklink_sdk_f180_ZkLinkSigner_new_from_seed,
        FfiConverterSequenceUInt8.lower(seed))
        return cls._make_instance_(pointer)
    @classmethod
    def new_from_hex_eth_signer(cls, eth_hex_private_key):
        eth_hex_private_key = eth_hex_private_key
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeZkSignerError,_UniFFILib.zklink_sdk_f180_ZkLinkSigner_new_from_hex_eth_signer,
        FfiConverterString.lower(eth_hex_private_key))
        return cls._make_instance_(pointer)
    @classmethod
    def new_from_hex_stark_signer(cls, hex_private_key,addr,chain_id):
        hex_private_key = hex_private_key
        
        addr = addr
        
        chain_id = chain_id
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeZkSignerError,_UniFFILib.zklink_sdk_f180_ZkLinkSigner_new_from_hex_stark_signer,
        FfiConverterString.lower(hex_private_key),
        FfiConverterString.lower(addr),
        FfiConverterString.lower(chain_id))
        return cls._make_instance_(pointer)
    @classmethod
    def new_from_bytes(cls, slice):
        slice = list(int(x) for x in slice)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeZkSignerError,_UniFFILib.zklink_sdk_f180_ZkLinkSigner_new_from_bytes,
        FfiConverterSequenceUInt8.lower(slice))
        return cls._make_instance_(pointer)
    

    def public_key(self, ):
        return FfiConverterTypePackedPublicKey.lift(
            rust_call(_UniFFILib.zklink_sdk_f180_ZkLinkSigner_public_key,self._pointer,)
        )
    def sign_musig(self, msg):
        msg = list(int(x) for x in msg)
        
        return FfiConverterTypeZkLinkSignature.lift(
            rust_call_with_error(
    FfiConverterTypeZkSignerError,_UniFFILib.zklink_sdk_f180_ZkLinkSigner_sign_musig,self._pointer,
        FfiConverterSequenceUInt8.lower(msg))
        )
    


class FfiConverterTypeZkLinkSigner:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ZkLinkSigner):
            raise TypeError("Expected ZkLinkSigner instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ZkLinkSigner._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer


class AutoDeleveragingBuilder:

    def __init__(self, account_id, sub_account_id, sub_account_nonce, contract_prices, margin_prices, adl_account_id, pair_id, adl_size, adl_price, fee, fee_token):
        self.account_id = account_id
        self.sub_account_id = sub_account_id
        self.sub_account_nonce = sub_account_nonce
        self.contract_prices = contract_prices
        self.margin_prices = margin_prices
        self.adl_account_id = adl_account_id
        self.pair_id = pair_id
        self.adl_size = adl_size
        self.adl_price = adl_price
        self.fee = fee
        self.fee_token = fee_token

    def __str__(self):
        return "AutoDeleveragingBuilder(account_id={}, sub_account_id={}, sub_account_nonce={}, contract_prices={}, margin_prices={}, adl_account_id={}, pair_id={}, adl_size={}, adl_price={}, fee={}, fee_token={})".format(self.account_id, self.sub_account_id, self.sub_account_nonce, self.contract_prices, self.margin_prices, self.adl_account_id, self.pair_id, self.adl_size, self.adl_price, self.fee, self.fee_token)

    def __eq__(self, other):
        if self.account_id != other.account_id:
            return False
        if self.sub_account_id != other.sub_account_id:
            return False
        if self.sub_account_nonce != other.sub_account_nonce:
            return False
        if self.contract_prices != other.contract_prices:
            return False
        if self.margin_prices != other.margin_prices:
            return False
        if self.adl_account_id != other.adl_account_id:
            return False
        if self.pair_id != other.pair_id:
            return False
        if self.adl_size != other.adl_size:
            return False
        if self.adl_price != other.adl_price:
            return False
        if self.fee != other.fee:
            return False
        if self.fee_token != other.fee_token:
            return False
        return True

class FfiConverterTypeAutoDeleveragingBuilder(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AutoDeleveragingBuilder(
            account_id=FfiConverterTypeAccountId.read(buf),
            sub_account_id=FfiConverterTypeSubAccountId.read(buf),
            sub_account_nonce=FfiConverterTypeNonce.read(buf),
            contract_prices=FfiConverterSequenceTypeContractPrice.read(buf),
            margin_prices=FfiConverterSequenceTypeSpotPriceInfo.read(buf),
            adl_account_id=FfiConverterTypeAccountId.read(buf),
            pair_id=FfiConverterTypePairId.read(buf),
            adl_size=FfiConverterTypeBigUint.read(buf),
            adl_price=FfiConverterTypeBigUint.read(buf),
            fee=FfiConverterTypeBigUint.read(buf),
            fee_token=FfiConverterTypeTokenId.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterTypeAccountId.write(value.account_id, buf)
        FfiConverterTypeSubAccountId.write(value.sub_account_id, buf)
        FfiConverterTypeNonce.write(value.sub_account_nonce, buf)
        FfiConverterSequenceTypeContractPrice.write(value.contract_prices, buf)
        FfiConverterSequenceTypeSpotPriceInfo.write(value.margin_prices, buf)
        FfiConverterTypeAccountId.write(value.adl_account_id, buf)
        FfiConverterTypePairId.write(value.pair_id, buf)
        FfiConverterTypeBigUint.write(value.adl_size, buf)
        FfiConverterTypeBigUint.write(value.adl_price, buf)
        FfiConverterTypeBigUint.write(value.fee, buf)
        FfiConverterTypeTokenId.write(value.fee_token, buf)


class ChangePubKeyBuilder:

    def __init__(self, chain_id, account_id, sub_account_id, new_pubkey_hash, fee_token, fee, nonce, eth_signature, timestamp):
        self.chain_id = chain_id
        self.account_id = account_id
        self.sub_account_id = sub_account_id
        self.new_pubkey_hash = new_pubkey_hash
        self.fee_token = fee_token
        self.fee = fee
        self.nonce = nonce
        self.eth_signature = eth_signature
        self.timestamp = timestamp

    def __str__(self):
        return "ChangePubKeyBuilder(chain_id={}, account_id={}, sub_account_id={}, new_pubkey_hash={}, fee_token={}, fee={}, nonce={}, eth_signature={}, timestamp={})".format(self.chain_id, self.account_id, self.sub_account_id, self.new_pubkey_hash, self.fee_token, self.fee, self.nonce, self.eth_signature, self.timestamp)

    def __eq__(self, other):
        if self.chain_id != other.chain_id:
            return False
        if self.account_id != other.account_id:
            return False
        if self.sub_account_id != other.sub_account_id:
            return False
        if self.new_pubkey_hash != other.new_pubkey_hash:
            return False
        if self.fee_token != other.fee_token:
            return False
        if self.fee != other.fee:
            return False
        if self.nonce != other.nonce:
            return False
        if self.eth_signature != other.eth_signature:
            return False
        if self.timestamp != other.timestamp:
            return False
        return True

class FfiConverterTypeChangePubKeyBuilder(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ChangePubKeyBuilder(
            chain_id=FfiConverterTypeChainId.read(buf),
            account_id=FfiConverterTypeAccountId.read(buf),
            sub_account_id=FfiConverterTypeSubAccountId.read(buf),
            new_pubkey_hash=FfiConverterTypePubKeyHash.read(buf),
            fee_token=FfiConverterTypeTokenId.read(buf),
            fee=FfiConverterTypeBigUint.read(buf),
            nonce=FfiConverterTypeNonce.read(buf),
            eth_signature=FfiConverterOptionalTypePackedEthSignature.read(buf),
            timestamp=FfiConverterTypeTimeStamp.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterTypeChainId.write(value.chain_id, buf)
        FfiConverterTypeAccountId.write(value.account_id, buf)
        FfiConverterTypeSubAccountId.write(value.sub_account_id, buf)
        FfiConverterTypePubKeyHash.write(value.new_pubkey_hash, buf)
        FfiConverterTypeTokenId.write(value.fee_token, buf)
        FfiConverterTypeBigUint.write(value.fee, buf)
        FfiConverterTypeNonce.write(value.nonce, buf)
        FfiConverterOptionalTypePackedEthSignature.write(value.eth_signature, buf)
        FfiConverterTypeTimeStamp.write(value.timestamp, buf)


class ContractBuilder:

    def __init__(self, account_id, sub_account_id, slot_id, nonce, pair_id, size, price, direction, taker_fee_rate, maker_fee_rate, has_subsidy):
        self.account_id = account_id
        self.sub_account_id = sub_account_id
        self.slot_id = slot_id
        self.nonce = nonce
        self.pair_id = pair_id
        self.size = size
        self.price = price
        self.direction = direction
        self.taker_fee_rate = taker_fee_rate
        self.maker_fee_rate = maker_fee_rate
        self.has_subsidy = has_subsidy

    def __str__(self):
        return "ContractBuilder(account_id={}, sub_account_id={}, slot_id={}, nonce={}, pair_id={}, size={}, price={}, direction={}, taker_fee_rate={}, maker_fee_rate={}, has_subsidy={})".format(self.account_id, self.sub_account_id, self.slot_id, self.nonce, self.pair_id, self.size, self.price, self.direction, self.taker_fee_rate, self.maker_fee_rate, self.has_subsidy)

    def __eq__(self, other):
        if self.account_id != other.account_id:
            return False
        if self.sub_account_id != other.sub_account_id:
            return False
        if self.slot_id != other.slot_id:
            return False
        if self.nonce != other.nonce:
            return False
        if self.pair_id != other.pair_id:
            return False
        if self.size != other.size:
            return False
        if self.price != other.price:
            return False
        if self.direction != other.direction:
            return False
        if self.taker_fee_rate != other.taker_fee_rate:
            return False
        if self.maker_fee_rate != other.maker_fee_rate:
            return False
        if self.has_subsidy != other.has_subsidy:
            return False
        return True

class FfiConverterTypeContractBuilder(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ContractBuilder(
            account_id=FfiConverterTypeAccountId.read(buf),
            sub_account_id=FfiConverterTypeSubAccountId.read(buf),
            slot_id=FfiConverterTypeSlotId.read(buf),
            nonce=FfiConverterTypeNonce.read(buf),
            pair_id=FfiConverterTypePairId.read(buf),
            size=FfiConverterTypeBigUint.read(buf),
            price=FfiConverterTypeBigUint.read(buf),
            direction=FfiConverterBool.read(buf),
            taker_fee_rate=FfiConverterUInt8.read(buf),
            maker_fee_rate=FfiConverterUInt8.read(buf),
            has_subsidy=FfiConverterBool.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterTypeAccountId.write(value.account_id, buf)
        FfiConverterTypeSubAccountId.write(value.sub_account_id, buf)
        FfiConverterTypeSlotId.write(value.slot_id, buf)
        FfiConverterTypeNonce.write(value.nonce, buf)
        FfiConverterTypePairId.write(value.pair_id, buf)
        FfiConverterTypeBigUint.write(value.size, buf)
        FfiConverterTypeBigUint.write(value.price, buf)
        FfiConverterBool.write(value.direction, buf)
        FfiConverterUInt8.write(value.taker_fee_rate, buf)
        FfiConverterUInt8.write(value.maker_fee_rate, buf)
        FfiConverterBool.write(value.has_subsidy, buf)


class ContractMatchingBuilder:

    def __init__(self, account_id, sub_account_id, taker, maker, fee, fee_token, contract_prices, margin_prices):
        self.account_id = account_id
        self.sub_account_id = sub_account_id
        self.taker = taker
        self.maker = maker
        self.fee = fee
        self.fee_token = fee_token
        self.contract_prices = contract_prices
        self.margin_prices = margin_prices

    def __str__(self):
        return "ContractMatchingBuilder(account_id={}, sub_account_id={}, taker={}, maker={}, fee={}, fee_token={}, contract_prices={}, margin_prices={})".format(self.account_id, self.sub_account_id, self.taker, self.maker, self.fee, self.fee_token, self.contract_prices, self.margin_prices)

    def __eq__(self, other):
        if self.account_id != other.account_id:
            return False
        if self.sub_account_id != other.sub_account_id:
            return False
        if self.taker != other.taker:
            return False
        if self.maker != other.maker:
            return False
        if self.fee != other.fee:
            return False
        if self.fee_token != other.fee_token:
            return False
        if self.contract_prices != other.contract_prices:
            return False
        if self.margin_prices != other.margin_prices:
            return False
        return True

class FfiConverterTypeContractMatchingBuilder(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ContractMatchingBuilder(
            account_id=FfiConverterTypeAccountId.read(buf),
            sub_account_id=FfiConverterTypeSubAccountId.read(buf),
            taker=FfiConverterTypeContract.read(buf),
            maker=FfiConverterSequenceTypeContract.read(buf),
            fee=FfiConverterTypeBigUint.read(buf),
            fee_token=FfiConverterTypeTokenId.read(buf),
            contract_prices=FfiConverterSequenceTypeContractPrice.read(buf),
            margin_prices=FfiConverterSequenceTypeSpotPriceInfo.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterTypeAccountId.write(value.account_id, buf)
        FfiConverterTypeSubAccountId.write(value.sub_account_id, buf)
        FfiConverterTypeContract.write(value.taker, buf)
        FfiConverterSequenceTypeContract.write(value.maker, buf)
        FfiConverterTypeBigUint.write(value.fee, buf)
        FfiConverterTypeTokenId.write(value.fee_token, buf)
        FfiConverterSequenceTypeContractPrice.write(value.contract_prices, buf)
        FfiConverterSequenceTypeSpotPriceInfo.write(value.margin_prices, buf)


class ContractPrice:

    def __init__(self, pair_id, market_price):
        self.pair_id = pair_id
        self.market_price = market_price

    def __str__(self):
        return "ContractPrice(pair_id={}, market_price={})".format(self.pair_id, self.market_price)

    def __eq__(self, other):
        if self.pair_id != other.pair_id:
            return False
        if self.market_price != other.market_price:
            return False
        return True

class FfiConverterTypeContractPrice(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ContractPrice(
            pair_id=FfiConverterTypePairId.read(buf),
            market_price=FfiConverterTypeBigUint.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterTypePairId.write(value.pair_id, buf)
        FfiConverterTypeBigUint.write(value.market_price, buf)


class Create2Data:

    def __init__(self, creator_address, salt_arg, code_hash):
        self.creator_address = creator_address
        self.salt_arg = salt_arg
        self.code_hash = code_hash

    def __str__(self):
        return "Create2Data(creator_address={}, salt_arg={}, code_hash={})".format(self.creator_address, self.salt_arg, self.code_hash)

    def __eq__(self, other):
        if self.creator_address != other.creator_address:
            return False
        if self.salt_arg != other.salt_arg:
            return False
        if self.code_hash != other.code_hash:
            return False
        return True

class FfiConverterTypeCreate2Data(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Create2Data(
            creator_address=FfiConverterTypeZkLinkAddress.read(buf),
            salt_arg=FfiConverterTypeH256.read(buf),
            code_hash=FfiConverterTypeH256.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterTypeZkLinkAddress.write(value.creator_address, buf)
        FfiConverterTypeH256.write(value.salt_arg, buf)
        FfiConverterTypeH256.write(value.code_hash, buf)


class DepositBuilder:

    def __init__(self, from_address, to_address, from_chain_id, sub_account_id, l2_target_token, l1_source_token, amount, serial_id, l2_hash, eth_hash):
        self.from_address = from_address
        self.to_address = to_address
        self.from_chain_id = from_chain_id
        self.sub_account_id = sub_account_id
        self.l2_target_token = l2_target_token
        self.l1_source_token = l1_source_token
        self.amount = amount
        self.serial_id = serial_id
        self.l2_hash = l2_hash
        self.eth_hash = eth_hash

    def __str__(self):
        return "DepositBuilder(from_address={}, to_address={}, from_chain_id={}, sub_account_id={}, l2_target_token={}, l1_source_token={}, amount={}, serial_id={}, l2_hash={}, eth_hash={})".format(self.from_address, self.to_address, self.from_chain_id, self.sub_account_id, self.l2_target_token, self.l1_source_token, self.amount, self.serial_id, self.l2_hash, self.eth_hash)

    def __eq__(self, other):
        if self.from_address != other.from_address:
            return False
        if self.to_address != other.to_address:
            return False
        if self.from_chain_id != other.from_chain_id:
            return False
        if self.sub_account_id != other.sub_account_id:
            return False
        if self.l2_target_token != other.l2_target_token:
            return False
        if self.l1_source_token != other.l1_source_token:
            return False
        if self.amount != other.amount:
            return False
        if self.serial_id != other.serial_id:
            return False
        if self.l2_hash != other.l2_hash:
            return False
        if self.eth_hash != other.eth_hash:
            return False
        return True

class FfiConverterTypeDepositBuilder(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DepositBuilder(
            from_address=FfiConverterTypeZkLinkAddress.read(buf),
            to_address=FfiConverterTypeZkLinkAddress.read(buf),
            from_chain_id=FfiConverterTypeChainId.read(buf),
            sub_account_id=FfiConverterTypeSubAccountId.read(buf),
            l2_target_token=FfiConverterTypeTokenId.read(buf),
            l1_source_token=FfiConverterTypeTokenId.read(buf),
            amount=FfiConverterTypeBigUint.read(buf),
            serial_id=FfiConverterUInt64.read(buf),
            l2_hash=FfiConverterTypeH256.read(buf),
            eth_hash=FfiConverterOptionalTypeH256.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterTypeZkLinkAddress.write(value.from_address, buf)
        FfiConverterTypeZkLinkAddress.write(value.to_address, buf)
        FfiConverterTypeChainId.write(value.from_chain_id, buf)
        FfiConverterTypeSubAccountId.write(value.sub_account_id, buf)
        FfiConverterTypeTokenId.write(value.l2_target_token, buf)
        FfiConverterTypeTokenId.write(value.l1_source_token, buf)
        FfiConverterTypeBigUint.write(value.amount, buf)
        FfiConverterUInt64.write(value.serial_id, buf)
        FfiConverterTypeH256.write(value.l2_hash, buf)
        FfiConverterOptionalTypeH256.write(value.eth_hash, buf)


class ForcedExitBuilder:

    def __init__(self, to_chain_id, initiator_account_id, initiator_sub_account_id, target, target_sub_account_id, l2_source_token, l1_target_token, initiator_nonce, exit_amount, withdraw_to_l1, timestamp):
        self.to_chain_id = to_chain_id
        self.initiator_account_id = initiator_account_id
        self.initiator_sub_account_id = initiator_sub_account_id
        self.target = target
        self.target_sub_account_id = target_sub_account_id
        self.l2_source_token = l2_source_token
        self.l1_target_token = l1_target_token
        self.initiator_nonce = initiator_nonce
        self.exit_amount = exit_amount
        self.withdraw_to_l1 = withdraw_to_l1
        self.timestamp = timestamp

    def __str__(self):
        return "ForcedExitBuilder(to_chain_id={}, initiator_account_id={}, initiator_sub_account_id={}, target={}, target_sub_account_id={}, l2_source_token={}, l1_target_token={}, initiator_nonce={}, exit_amount={}, withdraw_to_l1={}, timestamp={})".format(self.to_chain_id, self.initiator_account_id, self.initiator_sub_account_id, self.target, self.target_sub_account_id, self.l2_source_token, self.l1_target_token, self.initiator_nonce, self.exit_amount, self.withdraw_to_l1, self.timestamp)

    def __eq__(self, other):
        if self.to_chain_id != other.to_chain_id:
            return False
        if self.initiator_account_id != other.initiator_account_id:
            return False
        if self.initiator_sub_account_id != other.initiator_sub_account_id:
            return False
        if self.target != other.target:
            return False
        if self.target_sub_account_id != other.target_sub_account_id:
            return False
        if self.l2_source_token != other.l2_source_token:
            return False
        if self.l1_target_token != other.l1_target_token:
            return False
        if self.initiator_nonce != other.initiator_nonce:
            return False
        if self.exit_amount != other.exit_amount:
            return False
        if self.withdraw_to_l1 != other.withdraw_to_l1:
            return False
        if self.timestamp != other.timestamp:
            return False
        return True

class FfiConverterTypeForcedExitBuilder(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ForcedExitBuilder(
            to_chain_id=FfiConverterTypeChainId.read(buf),
            initiator_account_id=FfiConverterTypeAccountId.read(buf),
            initiator_sub_account_id=FfiConverterTypeSubAccountId.read(buf),
            target=FfiConverterTypeZkLinkAddress.read(buf),
            target_sub_account_id=FfiConverterTypeSubAccountId.read(buf),
            l2_source_token=FfiConverterTypeTokenId.read(buf),
            l1_target_token=FfiConverterTypeTokenId.read(buf),
            initiator_nonce=FfiConverterTypeNonce.read(buf),
            exit_amount=FfiConverterTypeBigUint.read(buf),
            withdraw_to_l1=FfiConverterBool.read(buf),
            timestamp=FfiConverterTypeTimeStamp.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterTypeChainId.write(value.to_chain_id, buf)
        FfiConverterTypeAccountId.write(value.initiator_account_id, buf)
        FfiConverterTypeSubAccountId.write(value.initiator_sub_account_id, buf)
        FfiConverterTypeZkLinkAddress.write(value.target, buf)
        FfiConverterTypeSubAccountId.write(value.target_sub_account_id, buf)
        FfiConverterTypeTokenId.write(value.l2_source_token, buf)
        FfiConverterTypeTokenId.write(value.l1_target_token, buf)
        FfiConverterTypeNonce.write(value.initiator_nonce, buf)
        FfiConverterTypeBigUint.write(value.exit_amount, buf)
        FfiConverterBool.write(value.withdraw_to_l1, buf)
        FfiConverterTypeTimeStamp.write(value.timestamp, buf)


class FullExitBuilder:

    def __init__(self, to_chain_id, account_id, sub_account_id, exit_address, l2_source_token, l1_target_token, contract_prices, margin_prices, serial_id, l2_hash):
        self.to_chain_id = to_chain_id
        self.account_id = account_id
        self.sub_account_id = sub_account_id
        self.exit_address = exit_address
        self.l2_source_token = l2_source_token
        self.l1_target_token = l1_target_token
        self.contract_prices = contract_prices
        self.margin_prices = margin_prices
        self.serial_id = serial_id
        self.l2_hash = l2_hash

    def __str__(self):
        return "FullExitBuilder(to_chain_id={}, account_id={}, sub_account_id={}, exit_address={}, l2_source_token={}, l1_target_token={}, contract_prices={}, margin_prices={}, serial_id={}, l2_hash={})".format(self.to_chain_id, self.account_id, self.sub_account_id, self.exit_address, self.l2_source_token, self.l1_target_token, self.contract_prices, self.margin_prices, self.serial_id, self.l2_hash)

    def __eq__(self, other):
        if self.to_chain_id != other.to_chain_id:
            return False
        if self.account_id != other.account_id:
            return False
        if self.sub_account_id != other.sub_account_id:
            return False
        if self.exit_address != other.exit_address:
            return False
        if self.l2_source_token != other.l2_source_token:
            return False
        if self.l1_target_token != other.l1_target_token:
            return False
        if self.contract_prices != other.contract_prices:
            return False
        if self.margin_prices != other.margin_prices:
            return False
        if self.serial_id != other.serial_id:
            return False
        if self.l2_hash != other.l2_hash:
            return False
        return True

class FfiConverterTypeFullExitBuilder(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FullExitBuilder(
            to_chain_id=FfiConverterTypeChainId.read(buf),
            account_id=FfiConverterTypeAccountId.read(buf),
            sub_account_id=FfiConverterTypeSubAccountId.read(buf),
            exit_address=FfiConverterTypeZkLinkAddress.read(buf),
            l2_source_token=FfiConverterTypeTokenId.read(buf),
            l1_target_token=FfiConverterTypeTokenId.read(buf),
            contract_prices=FfiConverterSequenceTypeContractPrice.read(buf),
            margin_prices=FfiConverterSequenceTypeSpotPriceInfo.read(buf),
            serial_id=FfiConverterUInt64.read(buf),
            l2_hash=FfiConverterTypeH256.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterTypeChainId.write(value.to_chain_id, buf)
        FfiConverterTypeAccountId.write(value.account_id, buf)
        FfiConverterTypeSubAccountId.write(value.sub_account_id, buf)
        FfiConverterTypeZkLinkAddress.write(value.exit_address, buf)
        FfiConverterTypeTokenId.write(value.l2_source_token, buf)
        FfiConverterTypeTokenId.write(value.l1_target_token, buf)
        FfiConverterSequenceTypeContractPrice.write(value.contract_prices, buf)
        FfiConverterSequenceTypeSpotPriceInfo.write(value.margin_prices, buf)
        FfiConverterUInt64.write(value.serial_id, buf)
        FfiConverterTypeH256.write(value.l2_hash, buf)


class FundingBuilder:

    def __init__(self, account_id, sub_account_id, sub_account_nonce, funding_account_ids, fee, fee_token):
        self.account_id = account_id
        self.sub_account_id = sub_account_id
        self.sub_account_nonce = sub_account_nonce
        self.funding_account_ids = funding_account_ids
        self.fee = fee
        self.fee_token = fee_token

    def __str__(self):
        return "FundingBuilder(account_id={}, sub_account_id={}, sub_account_nonce={}, funding_account_ids={}, fee={}, fee_token={})".format(self.account_id, self.sub_account_id, self.sub_account_nonce, self.funding_account_ids, self.fee, self.fee_token)

    def __eq__(self, other):
        if self.account_id != other.account_id:
            return False
        if self.sub_account_id != other.sub_account_id:
            return False
        if self.sub_account_nonce != other.sub_account_nonce:
            return False
        if self.funding_account_ids != other.funding_account_ids:
            return False
        if self.fee != other.fee:
            return False
        if self.fee_token != other.fee_token:
            return False
        return True

class FfiConverterTypeFundingBuilder(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FundingBuilder(
            account_id=FfiConverterTypeAccountId.read(buf),
            sub_account_id=FfiConverterTypeSubAccountId.read(buf),
            sub_account_nonce=FfiConverterTypeNonce.read(buf),
            funding_account_ids=FfiConverterSequenceTypeAccountId.read(buf),
            fee=FfiConverterTypeBigUint.read(buf),
            fee_token=FfiConverterTypeTokenId.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterTypeAccountId.write(value.account_id, buf)
        FfiConverterTypeSubAccountId.write(value.sub_account_id, buf)
        FfiConverterTypeNonce.write(value.sub_account_nonce, buf)
        FfiConverterSequenceTypeAccountId.write(value.funding_account_ids, buf)
        FfiConverterTypeBigUint.write(value.fee, buf)
        FfiConverterTypeTokenId.write(value.fee_token, buf)


class FundingInfo:

    def __init__(self, pair_id, price, funding_rate):
        self.pair_id = pair_id
        self.price = price
        self.funding_rate = funding_rate

    def __str__(self):
        return "FundingInfo(pair_id={}, price={}, funding_rate={})".format(self.pair_id, self.price, self.funding_rate)

    def __eq__(self, other):
        if self.pair_id != other.pair_id:
            return False
        if self.price != other.price:
            return False
        if self.funding_rate != other.funding_rate:
            return False
        return True

class FfiConverterTypeFundingInfo(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FundingInfo(
            pair_id=FfiConverterTypePairId.read(buf),
            price=FfiConverterTypeBigUint.read(buf),
            funding_rate=FfiConverterInt16.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterTypePairId.write(value.pair_id, buf)
        FfiConverterTypeBigUint.write(value.price, buf)
        FfiConverterInt16.write(value.funding_rate, buf)


class LiquidationBuilder:

    def __init__(self, account_id, sub_account_id, sub_account_nonce, contract_prices, margin_prices, liquidation_account_id, fee, fee_token):
        self.account_id = account_id
        self.sub_account_id = sub_account_id
        self.sub_account_nonce = sub_account_nonce
        self.contract_prices = contract_prices
        self.margin_prices = margin_prices
        self.liquidation_account_id = liquidation_account_id
        self.fee = fee
        self.fee_token = fee_token

    def __str__(self):
        return "LiquidationBuilder(account_id={}, sub_account_id={}, sub_account_nonce={}, contract_prices={}, margin_prices={}, liquidation_account_id={}, fee={}, fee_token={})".format(self.account_id, self.sub_account_id, self.sub_account_nonce, self.contract_prices, self.margin_prices, self.liquidation_account_id, self.fee, self.fee_token)

    def __eq__(self, other):
        if self.account_id != other.account_id:
            return False
        if self.sub_account_id != other.sub_account_id:
            return False
        if self.sub_account_nonce != other.sub_account_nonce:
            return False
        if self.contract_prices != other.contract_prices:
            return False
        if self.margin_prices != other.margin_prices:
            return False
        if self.liquidation_account_id != other.liquidation_account_id:
            return False
        if self.fee != other.fee:
            return False
        if self.fee_token != other.fee_token:
            return False
        return True

class FfiConverterTypeLiquidationBuilder(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LiquidationBuilder(
            account_id=FfiConverterTypeAccountId.read(buf),
            sub_account_id=FfiConverterTypeSubAccountId.read(buf),
            sub_account_nonce=FfiConverterTypeNonce.read(buf),
            contract_prices=FfiConverterSequenceTypeContractPrice.read(buf),
            margin_prices=FfiConverterSequenceTypeSpotPriceInfo.read(buf),
            liquidation_account_id=FfiConverterTypeAccountId.read(buf),
            fee=FfiConverterTypeBigUint.read(buf),
            fee_token=FfiConverterTypeTokenId.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterTypeAccountId.write(value.account_id, buf)
        FfiConverterTypeSubAccountId.write(value.sub_account_id, buf)
        FfiConverterTypeNonce.write(value.sub_account_nonce, buf)
        FfiConverterSequenceTypeContractPrice.write(value.contract_prices, buf)
        FfiConverterSequenceTypeSpotPriceInfo.write(value.margin_prices, buf)
        FfiConverterTypeAccountId.write(value.liquidation_account_id, buf)
        FfiConverterTypeBigUint.write(value.fee, buf)
        FfiConverterTypeTokenId.write(value.fee_token, buf)


class Message:

    def __init__(self, data):
        self.data = data

    def __str__(self):
        return "Message(data={})".format(self.data)

    def __eq__(self, other):
        if self.data != other.data:
            return False
        return True

class FfiConverterTypeMessage(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Message(
            data=FfiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.data, buf)


class OraclePrices:

    def __init__(self, contract_prices, margin_prices):
        self.contract_prices = contract_prices
        self.margin_prices = margin_prices

    def __str__(self):
        return "OraclePrices(contract_prices={}, margin_prices={})".format(self.contract_prices, self.margin_prices)

    def __eq__(self, other):
        if self.contract_prices != other.contract_prices:
            return False
        if self.margin_prices != other.margin_prices:
            return False
        return True

class FfiConverterTypeOraclePrices(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return OraclePrices(
            contract_prices=FfiConverterSequenceTypeContractPrice.read(buf),
            margin_prices=FfiConverterSequenceTypeSpotPriceInfo.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterSequenceTypeContractPrice.write(value.contract_prices, buf)
        FfiConverterSequenceTypeSpotPriceInfo.write(value.margin_prices, buf)


class OrderMatchingBuilder:

    def __init__(self, account_id, sub_account_id, taker, maker, fee, fee_token, contract_prices, margin_prices, expect_base_amount, expect_quote_amount):
        self.account_id = account_id
        self.sub_account_id = sub_account_id
        self.taker = taker
        self.maker = maker
        self.fee = fee
        self.fee_token = fee_token
        self.contract_prices = contract_prices
        self.margin_prices = margin_prices
        self.expect_base_amount = expect_base_amount
        self.expect_quote_amount = expect_quote_amount

    def __str__(self):
        return "OrderMatchingBuilder(account_id={}, sub_account_id={}, taker={}, maker={}, fee={}, fee_token={}, contract_prices={}, margin_prices={}, expect_base_amount={}, expect_quote_amount={})".format(self.account_id, self.sub_account_id, self.taker, self.maker, self.fee, self.fee_token, self.contract_prices, self.margin_prices, self.expect_base_amount, self.expect_quote_amount)

    def __eq__(self, other):
        if self.account_id != other.account_id:
            return False
        if self.sub_account_id != other.sub_account_id:
            return False
        if self.taker != other.taker:
            return False
        if self.maker != other.maker:
            return False
        if self.fee != other.fee:
            return False
        if self.fee_token != other.fee_token:
            return False
        if self.contract_prices != other.contract_prices:
            return False
        if self.margin_prices != other.margin_prices:
            return False
        if self.expect_base_amount != other.expect_base_amount:
            return False
        if self.expect_quote_amount != other.expect_quote_amount:
            return False
        return True

class FfiConverterTypeOrderMatchingBuilder(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return OrderMatchingBuilder(
            account_id=FfiConverterTypeAccountId.read(buf),
            sub_account_id=FfiConverterTypeSubAccountId.read(buf),
            taker=FfiConverterTypeOrder.read(buf),
            maker=FfiConverterTypeOrder.read(buf),
            fee=FfiConverterTypeBigUint.read(buf),
            fee_token=FfiConverterTypeTokenId.read(buf),
            contract_prices=FfiConverterSequenceTypeContractPrice.read(buf),
            margin_prices=FfiConverterSequenceTypeSpotPriceInfo.read(buf),
            expect_base_amount=FfiConverterTypeBigUint.read(buf),
            expect_quote_amount=FfiConverterTypeBigUint.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterTypeAccountId.write(value.account_id, buf)
        FfiConverterTypeSubAccountId.write(value.sub_account_id, buf)
        FfiConverterTypeOrder.write(value.taker, buf)
        FfiConverterTypeOrder.write(value.maker, buf)
        FfiConverterTypeBigUint.write(value.fee, buf)
        FfiConverterTypeTokenId.write(value.fee_token, buf)
        FfiConverterSequenceTypeContractPrice.write(value.contract_prices, buf)
        FfiConverterSequenceTypeSpotPriceInfo.write(value.margin_prices, buf)
        FfiConverterTypeBigUint.write(value.expect_base_amount, buf)
        FfiConverterTypeBigUint.write(value.expect_quote_amount, buf)


class SpotPriceInfo:

    def __init__(self, token_id, price):
        self.token_id = token_id
        self.price = price

    def __str__(self):
        return "SpotPriceInfo(token_id={}, price={})".format(self.token_id, self.price)

    def __eq__(self, other):
        if self.token_id != other.token_id:
            return False
        if self.price != other.price:
            return False
        return True

class FfiConverterTypeSpotPriceInfo(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SpotPriceInfo(
            token_id=FfiConverterTypeTokenId.read(buf),
            price=FfiConverterTypeBigUint.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterTypeTokenId.write(value.token_id, buf)
        FfiConverterTypeBigUint.write(value.price, buf)


class TransferBuilder:

    def __init__(self, account_id, to_address, from_sub_account_id, to_sub_account_id, token, amount, fee, nonce, timestamp):
        self.account_id = account_id
        self.to_address = to_address
        self.from_sub_account_id = from_sub_account_id
        self.to_sub_account_id = to_sub_account_id
        self.token = token
        self.amount = amount
        self.fee = fee
        self.nonce = nonce
        self.timestamp = timestamp

    def __str__(self):
        return "TransferBuilder(account_id={}, to_address={}, from_sub_account_id={}, to_sub_account_id={}, token={}, amount={}, fee={}, nonce={}, timestamp={})".format(self.account_id, self.to_address, self.from_sub_account_id, self.to_sub_account_id, self.token, self.amount, self.fee, self.nonce, self.timestamp)

    def __eq__(self, other):
        if self.account_id != other.account_id:
            return False
        if self.to_address != other.to_address:
            return False
        if self.from_sub_account_id != other.from_sub_account_id:
            return False
        if self.to_sub_account_id != other.to_sub_account_id:
            return False
        if self.token != other.token:
            return False
        if self.amount != other.amount:
            return False
        if self.fee != other.fee:
            return False
        if self.nonce != other.nonce:
            return False
        if self.timestamp != other.timestamp:
            return False
        return True

class FfiConverterTypeTransferBuilder(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TransferBuilder(
            account_id=FfiConverterTypeAccountId.read(buf),
            to_address=FfiConverterTypeZkLinkAddress.read(buf),
            from_sub_account_id=FfiConverterTypeSubAccountId.read(buf),
            to_sub_account_id=FfiConverterTypeSubAccountId.read(buf),
            token=FfiConverterTypeTokenId.read(buf),
            amount=FfiConverterTypeBigUint.read(buf),
            fee=FfiConverterTypeBigUint.read(buf),
            nonce=FfiConverterTypeNonce.read(buf),
            timestamp=FfiConverterTypeTimeStamp.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterTypeAccountId.write(value.account_id, buf)
        FfiConverterTypeZkLinkAddress.write(value.to_address, buf)
        FfiConverterTypeSubAccountId.write(value.from_sub_account_id, buf)
        FfiConverterTypeSubAccountId.write(value.to_sub_account_id, buf)
        FfiConverterTypeTokenId.write(value.token, buf)
        FfiConverterTypeBigUint.write(value.amount, buf)
        FfiConverterTypeBigUint.write(value.fee, buf)
        FfiConverterTypeNonce.write(value.nonce, buf)
        FfiConverterTypeTimeStamp.write(value.timestamp, buf)


class TxMessage:

    def __init__(self, transaction, amount, fee, token, to, nonce):
        self.transaction = transaction
        self.amount = amount
        self.fee = fee
        self.token = token
        self.to = to
        self.nonce = nonce

    def __str__(self):
        return "TxMessage(transaction={}, amount={}, fee={}, token={}, to={}, nonce={})".format(self.transaction, self.amount, self.fee, self.token, self.to, self.nonce)

    def __eq__(self, other):
        if self.transaction != other.transaction:
            return False
        if self.amount != other.amount:
            return False
        if self.fee != other.fee:
            return False
        if self.token != other.token:
            return False
        if self.to != other.to:
            return False
        if self.nonce != other.nonce:
            return False
        return True

class FfiConverterTypeTxMessage(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TxMessage(
            transaction=FfiConverterString.read(buf),
            amount=FfiConverterString.read(buf),
            fee=FfiConverterString.read(buf),
            token=FfiConverterString.read(buf),
            to=FfiConverterString.read(buf),
            nonce=FfiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.transaction, buf)
        FfiConverterString.write(value.amount, buf)
        FfiConverterString.write(value.fee, buf)
        FfiConverterString.write(value.token, buf)
        FfiConverterString.write(value.to, buf)
        FfiConverterString.write(value.nonce, buf)


class TxSignature:

    def __init__(self, tx, layer1_signature):
        self.tx = tx
        self.layer1_signature = layer1_signature

    def __str__(self):
        return "TxSignature(tx={}, layer1_signature={})".format(self.tx, self.layer1_signature)

    def __eq__(self, other):
        if self.tx != other.tx:
            return False
        if self.layer1_signature != other.layer1_signature:
            return False
        return True

class FfiConverterTypeTxSignature(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TxSignature(
            tx=FfiConverterTypeZkLinkTx.read(buf),
            layer1_signature=FfiConverterOptionalTypeTxLayer1Signature.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterTypeZkLinkTx.write(value.tx, buf)
        FfiConverterOptionalTypeTxLayer1Signature.write(value.layer1_signature, buf)


class UpdateGlobalVarBuilder:

    def __init__(self, from_chain_id, sub_account_id, parameter, serial_id):
        self.from_chain_id = from_chain_id
        self.sub_account_id = sub_account_id
        self.parameter = parameter
        self.serial_id = serial_id

    def __str__(self):
        return "UpdateGlobalVarBuilder(from_chain_id={}, sub_account_id={}, parameter={}, serial_id={})".format(self.from_chain_id, self.sub_account_id, self.parameter, self.serial_id)

    def __eq__(self, other):
        if self.from_chain_id != other.from_chain_id:
            return False
        if self.sub_account_id != other.sub_account_id:
            return False
        if self.parameter != other.parameter:
            return False
        if self.serial_id != other.serial_id:
            return False
        return True

class FfiConverterTypeUpdateGlobalVarBuilder(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return UpdateGlobalVarBuilder(
            from_chain_id=FfiConverterTypeChainId.read(buf),
            sub_account_id=FfiConverterTypeSubAccountId.read(buf),
            parameter=FfiConverterTypeParameter.read(buf),
            serial_id=FfiConverterUInt64.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterTypeChainId.write(value.from_chain_id, buf)
        FfiConverterTypeSubAccountId.write(value.sub_account_id, buf)
        FfiConverterTypeParameter.write(value.parameter, buf)
        FfiConverterUInt64.write(value.serial_id, buf)


class WithdrawBuilder:

    def __init__(self, account_id, sub_account_id, to_chain_id, to_address, l2_source_token, l1_target_token, amount, call_data, fee, nonce, withdraw_fee_ratio, withdraw_to_l1, timestamp):
        self.account_id = account_id
        self.sub_account_id = sub_account_id
        self.to_chain_id = to_chain_id
        self.to_address = to_address
        self.l2_source_token = l2_source_token
        self.l1_target_token = l1_target_token
        self.amount = amount
        self.call_data = call_data
        self.fee = fee
        self.nonce = nonce
        self.withdraw_fee_ratio = withdraw_fee_ratio
        self.withdraw_to_l1 = withdraw_to_l1
        self.timestamp = timestamp

    def __str__(self):
        return "WithdrawBuilder(account_id={}, sub_account_id={}, to_chain_id={}, to_address={}, l2_source_token={}, l1_target_token={}, amount={}, call_data={}, fee={}, nonce={}, withdraw_fee_ratio={}, withdraw_to_l1={}, timestamp={})".format(self.account_id, self.sub_account_id, self.to_chain_id, self.to_address, self.l2_source_token, self.l1_target_token, self.amount, self.call_data, self.fee, self.nonce, self.withdraw_fee_ratio, self.withdraw_to_l1, self.timestamp)

    def __eq__(self, other):
        if self.account_id != other.account_id:
            return False
        if self.sub_account_id != other.sub_account_id:
            return False
        if self.to_chain_id != other.to_chain_id:
            return False
        if self.to_address != other.to_address:
            return False
        if self.l2_source_token != other.l2_source_token:
            return False
        if self.l1_target_token != other.l1_target_token:
            return False
        if self.amount != other.amount:
            return False
        if self.call_data != other.call_data:
            return False
        if self.fee != other.fee:
            return False
        if self.nonce != other.nonce:
            return False
        if self.withdraw_fee_ratio != other.withdraw_fee_ratio:
            return False
        if self.withdraw_to_l1 != other.withdraw_to_l1:
            return False
        if self.timestamp != other.timestamp:
            return False
        return True

class FfiConverterTypeWithdrawBuilder(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return WithdrawBuilder(
            account_id=FfiConverterTypeAccountId.read(buf),
            sub_account_id=FfiConverterTypeSubAccountId.read(buf),
            to_chain_id=FfiConverterTypeChainId.read(buf),
            to_address=FfiConverterTypeZkLinkAddress.read(buf),
            l2_source_token=FfiConverterTypeTokenId.read(buf),
            l1_target_token=FfiConverterTypeTokenId.read(buf),
            amount=FfiConverterTypeBigUint.read(buf),
            call_data=FfiConverterOptionalSequenceUInt8.read(buf),
            fee=FfiConverterTypeBigUint.read(buf),
            nonce=FfiConverterTypeNonce.read(buf),
            withdraw_fee_ratio=FfiConverterUInt16.read(buf),
            withdraw_to_l1=FfiConverterBool.read(buf),
            timestamp=FfiConverterTypeTimeStamp.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterTypeAccountId.write(value.account_id, buf)
        FfiConverterTypeSubAccountId.write(value.sub_account_id, buf)
        FfiConverterTypeChainId.write(value.to_chain_id, buf)
        FfiConverterTypeZkLinkAddress.write(value.to_address, buf)
        FfiConverterTypeTokenId.write(value.l2_source_token, buf)
        FfiConverterTypeTokenId.write(value.l1_target_token, buf)
        FfiConverterTypeBigUint.write(value.amount, buf)
        FfiConverterOptionalSequenceUInt8.write(value.call_data, buf)
        FfiConverterTypeBigUint.write(value.fee, buf)
        FfiConverterTypeNonce.write(value.nonce, buf)
        FfiConverterUInt16.write(value.withdraw_fee_ratio, buf)
        FfiConverterBool.write(value.withdraw_to_l1, buf)
        FfiConverterTypeTimeStamp.write(value.timestamp, buf)


class ZkLinkSignature:

    def __init__(self, pub_key, signature):
        self.pub_key = pub_key
        self.signature = signature

    def __str__(self):
        return "ZkLinkSignature(pub_key={}, signature={})".format(self.pub_key, self.signature)

    def __eq__(self, other):
        if self.pub_key != other.pub_key:
            return False
        if self.signature != other.signature:
            return False
        return True

class FfiConverterTypeZkLinkSignature(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ZkLinkSignature(
            pub_key=FfiConverterTypePackedPublicKey.read(buf),
            signature=FfiConverterTypePackedSignature.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterTypePackedPublicKey.write(value.pub_key, buf)
        FfiConverterTypePackedSignature.write(value.signature, buf)




class ChangePubKeyAuthData:
    def __init__(self):
        raise RuntimeError("ChangePubKeyAuthData cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class ONCHAIN(object):
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "ChangePubKeyAuthData.ONCHAIN()".format()

        def __eq__(self, other):
            if not other.is_onchain():
                return False
            return True
    class ETH_ECDSA(object):
        def __init__(self,eth_signature):
            
            self.eth_signature = eth_signature
            

        def __str__(self):
            return "ChangePubKeyAuthData.ETH_ECDSA(eth_signature={})".format(self.eth_signature)

        def __eq__(self, other):
            if not other.is_eth_ecdsa():
                return False
            if self.eth_signature != other.eth_signature:
                return False
            return True
    class ETH_CREATE2(object):
        def __init__(self,data):
            
            self.data = data
            

        def __str__(self):
            return "ChangePubKeyAuthData.ETH_CREATE2(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_eth_create2():
                return False
            if self.data != other.data:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_onchain(self):
        return isinstance(self, ChangePubKeyAuthData.ONCHAIN)
    def is_eth_ecdsa(self):
        return isinstance(self, ChangePubKeyAuthData.ETH_ECDSA)
    def is_eth_create2(self):
        return isinstance(self, ChangePubKeyAuthData.ETH_CREATE2)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ChangePubKeyAuthData.ONCHAIN = type("ChangePubKeyAuthData.ONCHAIN", (ChangePubKeyAuthData.ONCHAIN, ChangePubKeyAuthData,), {})
ChangePubKeyAuthData.ETH_ECDSA = type("ChangePubKeyAuthData.ETH_ECDSA", (ChangePubKeyAuthData.ETH_ECDSA, ChangePubKeyAuthData,), {})
ChangePubKeyAuthData.ETH_CREATE2 = type("ChangePubKeyAuthData.ETH_CREATE2", (ChangePubKeyAuthData.ETH_CREATE2, ChangePubKeyAuthData,), {})




class FfiConverterTypeChangePubKeyAuthData(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return ChangePubKeyAuthData.ONCHAIN(
            )
        if variant == 2:
            return ChangePubKeyAuthData.ETH_ECDSA(
                FfiConverterTypePackedEthSignature.read(buf),
            )
        if variant == 3:
            return ChangePubKeyAuthData.ETH_CREATE2(
                FfiConverterTypeCreate2Data.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_onchain():
            buf.writeI32(1)
        if value.is_eth_ecdsa():
            buf.writeI32(2)
            FfiConverterTypePackedEthSignature.write(value.eth_signature, buf)
        if value.is_eth_create2():
            buf.writeI32(3)
            FfiConverterTypeCreate2Data.write(value.data, buf)




class ChangePubKeyAuthRequest:
    def __init__(self):
        raise RuntimeError("ChangePubKeyAuthRequest cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class ONCHAIN(object):
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "ChangePubKeyAuthRequest.ONCHAIN()".format()

        def __eq__(self, other):
            if not other.is_onchain():
                return False
            return True
    class ETH_ECDSA(object):
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "ChangePubKeyAuthRequest.ETH_ECDSA()".format()

        def __eq__(self, other):
            if not other.is_eth_ecdsa():
                return False
            return True
    class ETH_CREATE2(object):
        def __init__(self,data):
            
            self.data = data
            

        def __str__(self):
            return "ChangePubKeyAuthRequest.ETH_CREATE2(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_eth_create2():
                return False
            if self.data != other.data:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_onchain(self):
        return isinstance(self, ChangePubKeyAuthRequest.ONCHAIN)
    def is_eth_ecdsa(self):
        return isinstance(self, ChangePubKeyAuthRequest.ETH_ECDSA)
    def is_eth_create2(self):
        return isinstance(self, ChangePubKeyAuthRequest.ETH_CREATE2)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ChangePubKeyAuthRequest.ONCHAIN = type("ChangePubKeyAuthRequest.ONCHAIN", (ChangePubKeyAuthRequest.ONCHAIN, ChangePubKeyAuthRequest,), {})
ChangePubKeyAuthRequest.ETH_ECDSA = type("ChangePubKeyAuthRequest.ETH_ECDSA", (ChangePubKeyAuthRequest.ETH_ECDSA, ChangePubKeyAuthRequest,), {})
ChangePubKeyAuthRequest.ETH_CREATE2 = type("ChangePubKeyAuthRequest.ETH_CREATE2", (ChangePubKeyAuthRequest.ETH_CREATE2, ChangePubKeyAuthRequest,), {})




class FfiConverterTypeChangePubKeyAuthRequest(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return ChangePubKeyAuthRequest.ONCHAIN(
            )
        if variant == 2:
            return ChangePubKeyAuthRequest.ETH_ECDSA(
            )
        if variant == 3:
            return ChangePubKeyAuthRequest.ETH_CREATE2(
                FfiConverterTypeCreate2Data.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_onchain():
            buf.writeI32(1)
        if value.is_eth_ecdsa():
            buf.writeI32(2)
        if value.is_eth_create2():
            buf.writeI32(3)
            FfiConverterTypeCreate2Data.write(value.data, buf)




class L1SignerType:
    def __init__(self):
        raise RuntimeError("L1SignerType cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class ETH(object):
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "L1SignerType.ETH()".format()

        def __eq__(self, other):
            if not other.is_eth():
                return False
            return True
    class STARKNET(object):
        def __init__(self,chain_id, address):
            
            self.chain_id = chain_id
            self.address = address
            

        def __str__(self):
            return "L1SignerType.STARKNET(chain_id={}, address={})".format(self.chain_id, self.address)

        def __eq__(self, other):
            if not other.is_starknet():
                return False
            if self.chain_id != other.chain_id:
                return False
            if self.address != other.address:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_eth(self):
        return isinstance(self, L1SignerType.ETH)
    def is_starknet(self):
        return isinstance(self, L1SignerType.STARKNET)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
L1SignerType.ETH = type("L1SignerType.ETH", (L1SignerType.ETH, L1SignerType,), {})
L1SignerType.STARKNET = type("L1SignerType.STARKNET", (L1SignerType.STARKNET, L1SignerType,), {})




class FfiConverterTypeL1SignerType(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return L1SignerType.ETH(
            )
        if variant == 2:
            return L1SignerType.STARKNET(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_eth():
            buf.writeI32(1)
        if value.is_starknet():
            buf.writeI32(2)
            FfiConverterString.write(value.chain_id, buf)
            FfiConverterString.write(value.address, buf)




class L1Type(enum.Enum):
    ETH = 1
    STARKNET = 2
    


class FfiConverterTypeL1Type(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return L1Type.ETH
        if variant == 2:
            return L1Type.STARKNET
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == L1Type.ETH:
            buf.writeI32(1)
        if value == L1Type.STARKNET:
            buf.writeI32(2)




class Parameter:
    def __init__(self):
        raise RuntimeError("Parameter cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class FEE_ACCOUNT(object):
        def __init__(self,account_id):
            
            self.account_id = account_id
            

        def __str__(self):
            return "Parameter.FEE_ACCOUNT(account_id={})".format(self.account_id)

        def __eq__(self, other):
            if not other.is_fee_account():
                return False
            if self.account_id != other.account_id:
                return False
            return True
    class INSURANCE_FUND_ACCOUNT(object):
        def __init__(self,account_id):
            
            self.account_id = account_id
            

        def __str__(self):
            return "Parameter.INSURANCE_FUND_ACCOUNT(account_id={})".format(self.account_id)

        def __eq__(self, other):
            if not other.is_insurance_fund_account():
                return False
            if self.account_id != other.account_id:
                return False
            return True
    class MARGIN_INFO(object):
        def __init__(self,margin_id, token_id, ratio):
            
            self.margin_id = margin_id
            self.token_id = token_id
            self.ratio = ratio
            

        def __str__(self):
            return "Parameter.MARGIN_INFO(margin_id={}, token_id={}, ratio={})".format(self.margin_id, self.token_id, self.ratio)

        def __eq__(self, other):
            if not other.is_margin_info():
                return False
            if self.margin_id != other.margin_id:
                return False
            if self.token_id != other.token_id:
                return False
            if self.ratio != other.ratio:
                return False
            return True
    class FUNDING_INFOS(object):
        def __init__(self,infos):
            
            self.infos = infos
            

        def __str__(self):
            return "Parameter.FUNDING_INFOS(infos={})".format(self.infos)

        def __eq__(self, other):
            if not other.is_funding_infos():
                return False
            if self.infos != other.infos:
                return False
            return True
    class CONTRACT_INFO(object):
        def __init__(self,pair_id, symbol, initial_margin_rate, maintenance_margin_rate):
            
            self.pair_id = pair_id
            self.symbol = symbol
            self.initial_margin_rate = initial_margin_rate
            self.maintenance_margin_rate = maintenance_margin_rate
            

        def __str__(self):
            return "Parameter.CONTRACT_INFO(pair_id={}, symbol={}, initial_margin_rate={}, maintenance_margin_rate={})".format(self.pair_id, self.symbol, self.initial_margin_rate, self.maintenance_margin_rate)

        def __eq__(self, other):
            if not other.is_contract_info():
                return False
            if self.pair_id != other.pair_id:
                return False
            if self.symbol != other.symbol:
                return False
            if self.initial_margin_rate != other.initial_margin_rate:
                return False
            if self.maintenance_margin_rate != other.maintenance_margin_rate:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_fee_account(self):
        return isinstance(self, Parameter.FEE_ACCOUNT)
    def is_insurance_fund_account(self):
        return isinstance(self, Parameter.INSURANCE_FUND_ACCOUNT)
    def is_margin_info(self):
        return isinstance(self, Parameter.MARGIN_INFO)
    def is_funding_infos(self):
        return isinstance(self, Parameter.FUNDING_INFOS)
    def is_contract_info(self):
        return isinstance(self, Parameter.CONTRACT_INFO)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
Parameter.FEE_ACCOUNT = type("Parameter.FEE_ACCOUNT", (Parameter.FEE_ACCOUNT, Parameter,), {})
Parameter.INSURANCE_FUND_ACCOUNT = type("Parameter.INSURANCE_FUND_ACCOUNT", (Parameter.INSURANCE_FUND_ACCOUNT, Parameter,), {})
Parameter.MARGIN_INFO = type("Parameter.MARGIN_INFO", (Parameter.MARGIN_INFO, Parameter,), {})
Parameter.FUNDING_INFOS = type("Parameter.FUNDING_INFOS", (Parameter.FUNDING_INFOS, Parameter,), {})
Parameter.CONTRACT_INFO = type("Parameter.CONTRACT_INFO", (Parameter.CONTRACT_INFO, Parameter,), {})




class FfiConverterTypeParameter(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return Parameter.FEE_ACCOUNT(
                FfiConverterTypeAccountId.read(buf),
            )
        if variant == 2:
            return Parameter.INSURANCE_FUND_ACCOUNT(
                FfiConverterTypeAccountId.read(buf),
            )
        if variant == 3:
            return Parameter.MARGIN_INFO(
                FfiConverterTypeMarginId.read(buf),
                FfiConverterTypeTokenId.read(buf),
                FfiConverterUInt8.read(buf),
            )
        if variant == 4:
            return Parameter.FUNDING_INFOS(
                FfiConverterSequenceTypeFundingInfo.read(buf),
            )
        if variant == 5:
            return Parameter.CONTRACT_INFO(
                FfiConverterTypePairId.read(buf),
                FfiConverterString.read(buf),
                FfiConverterUInt16.read(buf),
                FfiConverterUInt16.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_fee_account():
            buf.writeI32(1)
            FfiConverterTypeAccountId.write(value.account_id, buf)
        if value.is_insurance_fund_account():
            buf.writeI32(2)
            FfiConverterTypeAccountId.write(value.account_id, buf)
        if value.is_margin_info():
            buf.writeI32(3)
            FfiConverterTypeMarginId.write(value.margin_id, buf)
            FfiConverterTypeTokenId.write(value.token_id, buf)
            FfiConverterUInt8.write(value.ratio, buf)
        if value.is_funding_infos():
            buf.writeI32(4)
            FfiConverterSequenceTypeFundingInfo.write(value.infos, buf)
        if value.is_contract_info():
            buf.writeI32(5)
            FfiConverterTypePairId.write(value.pair_id, buf)
            FfiConverterString.write(value.symbol, buf)
            FfiConverterUInt16.write(value.initial_margin_rate, buf)
            FfiConverterUInt16.write(value.maintenance_margin_rate, buf)




class TypedDataMessage:
    def __init__(self):
        raise RuntimeError("TypedDataMessage cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class CREATE_L2_KEY(object):
        def __init__(self,message):
            
            self.message = message
            

        def __str__(self):
            return "TypedDataMessage.CREATE_L2_KEY(message={})".format(self.message)

        def __eq__(self, other):
            if not other.is_create_l2_key():
                return False
            if self.message != other.message:
                return False
            return True
    class TRANSACTION(object):
        def __init__(self,message):
            
            self.message = message
            

        def __str__(self):
            return "TypedDataMessage.TRANSACTION(message={})".format(self.message)

        def __eq__(self, other):
            if not other.is_transaction():
                return False
            if self.message != other.message:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_create_l2_key(self):
        return isinstance(self, TypedDataMessage.CREATE_L2_KEY)
    def is_transaction(self):
        return isinstance(self, TypedDataMessage.TRANSACTION)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TypedDataMessage.CREATE_L2_KEY = type("TypedDataMessage.CREATE_L2_KEY", (TypedDataMessage.CREATE_L2_KEY, TypedDataMessage,), {})
TypedDataMessage.TRANSACTION = type("TypedDataMessage.TRANSACTION", (TypedDataMessage.TRANSACTION, TypedDataMessage,), {})




class FfiConverterTypeTypedDataMessage(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return TypedDataMessage.CREATE_L2_KEY(
                FfiConverterTypeMessage.read(buf),
            )
        if variant == 2:
            return TypedDataMessage.TRANSACTION(
                FfiConverterTypeTxMessage.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_create_l2_key():
            buf.writeI32(1)
            FfiConverterTypeMessage.write(value.message, buf)
        if value.is_transaction():
            buf.writeI32(2)
            FfiConverterTypeTxMessage.write(value.message, buf)



# EthSignerError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separated, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class UniFFIExceptionTmpNamespace:
    class EthSignerError(Exception):
        pass
    
    class InvalidEthSigner(EthSignerError):
        def __str__(self):
            return "EthSignerError.InvalidEthSigner({})".format(repr(super().__str__()))

    EthSignerError.InvalidEthSigner = InvalidEthSigner
    class MissingEthPrivateKey(EthSignerError):
        def __str__(self):
            return "EthSignerError.MissingEthPrivateKey({})".format(repr(super().__str__()))

    EthSignerError.MissingEthPrivateKey = MissingEthPrivateKey
    class MissingEthSigner(EthSignerError):
        def __str__(self):
            return "EthSignerError.MissingEthSigner({})".format(repr(super().__str__()))

    EthSignerError.MissingEthSigner = MissingEthSigner
    class SigningFailed(EthSignerError):
        def __str__(self):
            return "EthSignerError.SigningFailed({})".format(repr(super().__str__()))

    EthSignerError.SigningFailed = SigningFailed
    class UnlockingFailed(EthSignerError):
        def __str__(self):
            return "EthSignerError.UnlockingFailed({})".format(repr(super().__str__()))

    EthSignerError.UnlockingFailed = UnlockingFailed
    class InvalidRawTx(EthSignerError):
        def __str__(self):
            return "EthSignerError.InvalidRawTx({})".format(repr(super().__str__()))

    EthSignerError.InvalidRawTx = InvalidRawTx
    class Eip712Failed(EthSignerError):
        def __str__(self):
            return "EthSignerError.Eip712Failed({})".format(repr(super().__str__()))

    EthSignerError.Eip712Failed = Eip712Failed
    class NoSigningKey(EthSignerError):
        def __str__(self):
            return "EthSignerError.NoSigningKey({})".format(repr(super().__str__()))

    EthSignerError.NoSigningKey = NoSigningKey
    class DefineAddress(EthSignerError):
        def __str__(self):
            return "EthSignerError.DefineAddress({})".format(repr(super().__str__()))

    EthSignerError.DefineAddress = DefineAddress
    class RecoverAddress(EthSignerError):
        def __str__(self):
            return "EthSignerError.RecoverAddress({})".format(repr(super().__str__()))

    EthSignerError.RecoverAddress = RecoverAddress
    class LengthMismatched(EthSignerError):
        def __str__(self):
            return "EthSignerError.LengthMismatched({})".format(repr(super().__str__()))

    EthSignerError.LengthMismatched = LengthMismatched
    class CryptoError(EthSignerError):
        def __str__(self):
            return "EthSignerError.CryptoError({})".format(repr(super().__str__()))

    EthSignerError.CryptoError = CryptoError
    class InvalidSignatureStr(EthSignerError):
        def __str__(self):
            return "EthSignerError.InvalidSignatureStr({})".format(repr(super().__str__()))

    EthSignerError.InvalidSignatureStr = InvalidSignatureStr
    class CustomError(EthSignerError):
        def __str__(self):
            return "EthSignerError.CustomError({})".format(repr(super().__str__()))

    EthSignerError.CustomError = CustomError
    class RpcSignError(EthSignerError):
        def __str__(self):
            return "EthSignerError.RpcSignError({})".format(repr(super().__str__()))

    EthSignerError.RpcSignError = RpcSignError
EthSignerError = UniFFIExceptionTmpNamespace.EthSignerError
del UniFFIExceptionTmpNamespace


class FfiConverterTypeEthSignerError(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return EthSignerError.InvalidEthSigner(
                FfiConverterString.read(buf),
            )
        if variant == 2:
            return EthSignerError.MissingEthPrivateKey(
                FfiConverterString.read(buf),
            )
        if variant == 3:
            return EthSignerError.MissingEthSigner(
                FfiConverterString.read(buf),
            )
        if variant == 4:
            return EthSignerError.SigningFailed(
                FfiConverterString.read(buf),
            )
        if variant == 5:
            return EthSignerError.UnlockingFailed(
                FfiConverterString.read(buf),
            )
        if variant == 6:
            return EthSignerError.InvalidRawTx(
                FfiConverterString.read(buf),
            )
        if variant == 7:
            return EthSignerError.Eip712Failed(
                FfiConverterString.read(buf),
            )
        if variant == 8:
            return EthSignerError.NoSigningKey(
                FfiConverterString.read(buf),
            )
        if variant == 9:
            return EthSignerError.DefineAddress(
                FfiConverterString.read(buf),
            )
        if variant == 10:
            return EthSignerError.RecoverAddress(
                FfiConverterString.read(buf),
            )
        if variant == 11:
            return EthSignerError.LengthMismatched(
                FfiConverterString.read(buf),
            )
        if variant == 12:
            return EthSignerError.CryptoError(
                FfiConverterString.read(buf),
            )
        if variant == 13:
            return EthSignerError.InvalidSignatureStr(
                FfiConverterString.read(buf),
            )
        if variant == 14:
            return EthSignerError.CustomError(
                FfiConverterString.read(buf),
            )
        if variant == 15:
            return EthSignerError.RpcSignError(
                FfiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def write(value, buf):
        if isinstance(value, EthSignerError.InvalidEthSigner):
            buf.writeI32(1)
        if isinstance(value, EthSignerError.MissingEthPrivateKey):
            buf.writeI32(2)
        if isinstance(value, EthSignerError.MissingEthSigner):
            buf.writeI32(3)
        if isinstance(value, EthSignerError.SigningFailed):
            buf.writeI32(4)
        if isinstance(value, EthSignerError.UnlockingFailed):
            buf.writeI32(5)
        if isinstance(value, EthSignerError.InvalidRawTx):
            buf.writeI32(6)
        if isinstance(value, EthSignerError.Eip712Failed):
            buf.writeI32(7)
        if isinstance(value, EthSignerError.NoSigningKey):
            buf.writeI32(8)
        if isinstance(value, EthSignerError.DefineAddress):
            buf.writeI32(9)
        if isinstance(value, EthSignerError.RecoverAddress):
            buf.writeI32(10)
        if isinstance(value, EthSignerError.LengthMismatched):
            buf.writeI32(11)
        if isinstance(value, EthSignerError.CryptoError):
            buf.writeI32(12)
        if isinstance(value, EthSignerError.InvalidSignatureStr):
            buf.writeI32(13)
        if isinstance(value, EthSignerError.CustomError):
            buf.writeI32(14)
        if isinstance(value, EthSignerError.RpcSignError):
            buf.writeI32(15)



# SignError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separated, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class UniFFIExceptionTmpNamespace:
    class SignError(Exception):
        pass
    
    class EthSigningError(SignError):
        def __str__(self):
            return "SignError.EthSigningError({})".format(repr(super().__str__()))

    SignError.EthSigningError = EthSigningError
    class ZkSigningError(SignError):
        def __str__(self):
            return "SignError.ZkSigningError({})".format(repr(super().__str__()))

    SignError.ZkSigningError = ZkSigningError
    class StarkSigningError(SignError):
        def __str__(self):
            return "SignError.StarkSigningError({})".format(repr(super().__str__()))

    SignError.StarkSigningError = StarkSigningError
    class IncorrectTx(SignError):
        def __str__(self):
            return "SignError.IncorrectTx({})".format(repr(super().__str__()))

    SignError.IncorrectTx = IncorrectTx
SignError = UniFFIExceptionTmpNamespace.SignError
del UniFFIExceptionTmpNamespace


class FfiConverterTypeSignError(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return SignError.EthSigningError(
                FfiConverterString.read(buf),
            )
        if variant == 2:
            return SignError.ZkSigningError(
                FfiConverterString.read(buf),
            )
        if variant == 3:
            return SignError.StarkSigningError(
                FfiConverterString.read(buf),
            )
        if variant == 4:
            return SignError.IncorrectTx(
                FfiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def write(value, buf):
        if isinstance(value, SignError.EthSigningError):
            buf.writeI32(1)
        if isinstance(value, SignError.ZkSigningError):
            buf.writeI32(2)
        if isinstance(value, SignError.StarkSigningError):
            buf.writeI32(3)
        if isinstance(value, SignError.IncorrectTx):
            buf.writeI32(4)



# StarkSignerError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separated, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class UniFFIExceptionTmpNamespace:
    class StarkSignerError(Exception):
        pass
    
    class InvalidStarknetSigner(StarkSignerError):
        def __str__(self):
            return "StarkSignerError.InvalidStarknetSigner({})".format(repr(super().__str__()))

    StarkSignerError.InvalidStarknetSigner = InvalidStarknetSigner
    class InvalidSignature(StarkSignerError):
        def __str__(self):
            return "StarkSignerError.InvalidSignature({})".format(repr(super().__str__()))

    StarkSignerError.InvalidSignature = InvalidSignature
    class InvalidPrivKey(StarkSignerError):
        def __str__(self):
            return "StarkSignerError.InvalidPrivKey({})".format(repr(super().__str__()))

    StarkSignerError.InvalidPrivKey = InvalidPrivKey
    class SignError(StarkSignerError):
        def __str__(self):
            return "StarkSignerError.SignError({})".format(repr(super().__str__()))

    StarkSignerError.SignError = SignError
    class RpcSignError(StarkSignerError):
        def __str__(self):
            return "StarkSignerError.RpcSignError({})".format(repr(super().__str__()))

    StarkSignerError.RpcSignError = RpcSignError
StarkSignerError = UniFFIExceptionTmpNamespace.StarkSignerError
del UniFFIExceptionTmpNamespace


class FfiConverterTypeStarkSignerError(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return StarkSignerError.InvalidStarknetSigner(
                FfiConverterString.read(buf),
            )
        if variant == 2:
            return StarkSignerError.InvalidSignature(
                FfiConverterString.read(buf),
            )
        if variant == 3:
            return StarkSignerError.InvalidPrivKey(
                FfiConverterString.read(buf),
            )
        if variant == 4:
            return StarkSignerError.SignError(
                FfiConverterString.read(buf),
            )
        if variant == 5:
            return StarkSignerError.RpcSignError(
                FfiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def write(value, buf):
        if isinstance(value, StarkSignerError.InvalidStarknetSigner):
            buf.writeI32(1)
        if isinstance(value, StarkSignerError.InvalidSignature):
            buf.writeI32(2)
        if isinstance(value, StarkSignerError.InvalidPrivKey):
            buf.writeI32(3)
        if isinstance(value, StarkSignerError.SignError):
            buf.writeI32(4)
        if isinstance(value, StarkSignerError.RpcSignError):
            buf.writeI32(5)



# TypeError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separated, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class UniFFIExceptionTmpNamespace:
    class TypeError(Exception):
        pass
    
    class InvalidAddress(TypeError):
        def __str__(self):
            return "TypeError.InvalidAddress({})".format(repr(super().__str__()))

    TypeError.InvalidAddress = InvalidAddress
    class InvalidTxHash(TypeError):
        def __str__(self):
            return "TypeError.InvalidTxHash({})".format(repr(super().__str__()))

    TypeError.InvalidTxHash = InvalidTxHash
    class NotStartWithZerox(TypeError):
        def __str__(self):
            return "TypeError.NotStartWithZerox({})".format(repr(super().__str__()))

    TypeError.NotStartWithZerox = NotStartWithZerox
    class SizeMismatch(TypeError):
        def __str__(self):
            return "TypeError.SizeMismatch({})".format(repr(super().__str__()))

    TypeError.SizeMismatch = SizeMismatch
    class DecodeFromHexErr(TypeError):
        def __str__(self):
            return "TypeError.DecodeFromHexErr({})".format(repr(super().__str__()))

    TypeError.DecodeFromHexErr = DecodeFromHexErr
    class TooBigInteger(TypeError):
        def __str__(self):
            return "TypeError.TooBigInteger({})".format(repr(super().__str__()))

    TypeError.TooBigInteger = TooBigInteger
    class InvalidBigIntStr(TypeError):
        def __str__(self):
            return "TypeError.InvalidBigIntStr({})".format(repr(super().__str__()))

    TypeError.InvalidBigIntStr = InvalidBigIntStr
TypeError = UniFFIExceptionTmpNamespace.TypeError
del UniFFIExceptionTmpNamespace


class FfiConverterTypeTypeError(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return TypeError.InvalidAddress(
                FfiConverterString.read(buf),
            )
        if variant == 2:
            return TypeError.InvalidTxHash(
                FfiConverterString.read(buf),
            )
        if variant == 3:
            return TypeError.NotStartWithZerox(
                FfiConverterString.read(buf),
            )
        if variant == 4:
            return TypeError.SizeMismatch(
                FfiConverterString.read(buf),
            )
        if variant == 5:
            return TypeError.DecodeFromHexErr(
                FfiConverterString.read(buf),
            )
        if variant == 6:
            return TypeError.TooBigInteger(
                FfiConverterString.read(buf),
            )
        if variant == 7:
            return TypeError.InvalidBigIntStr(
                FfiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def write(value, buf):
        if isinstance(value, TypeError.InvalidAddress):
            buf.writeI32(1)
        if isinstance(value, TypeError.InvalidTxHash):
            buf.writeI32(2)
        if isinstance(value, TypeError.NotStartWithZerox):
            buf.writeI32(3)
        if isinstance(value, TypeError.SizeMismatch):
            buf.writeI32(4)
        if isinstance(value, TypeError.DecodeFromHexErr):
            buf.writeI32(5)
        if isinstance(value, TypeError.TooBigInteger):
            buf.writeI32(6)
        if isinstance(value, TypeError.InvalidBigIntStr):
            buf.writeI32(7)



# ZkSignerError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separated, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class UniFFIExceptionTmpNamespace:
    class ZkSignerError(Exception):
        pass
    
    class CustomError(ZkSignerError):
        def __str__(self):
            return "ZkSignerError.CustomError({})".format(repr(super().__str__()))

    ZkSignerError.CustomError = CustomError
    class InvalidSignature(ZkSignerError):
        def __str__(self):
            return "ZkSignerError.InvalidSignature({})".format(repr(super().__str__()))

    ZkSignerError.InvalidSignature = InvalidSignature
    class InvalidPrivKey(ZkSignerError):
        def __str__(self):
            return "ZkSignerError.InvalidPrivKey({})".format(repr(super().__str__()))

    ZkSignerError.InvalidPrivKey = InvalidPrivKey
    class InvalidSeed(ZkSignerError):
        def __str__(self):
            return "ZkSignerError.InvalidSeed({})".format(repr(super().__str__()))

    ZkSignerError.InvalidSeed = InvalidSeed
    class InvalidPubkey(ZkSignerError):
        def __str__(self):
            return "ZkSignerError.InvalidPubkey({})".format(repr(super().__str__()))

    ZkSignerError.InvalidPubkey = InvalidPubkey
    class InvalidPubkeyHash(ZkSignerError):
        def __str__(self):
            return "ZkSignerError.InvalidPubkeyHash({})".format(repr(super().__str__()))

    ZkSignerError.InvalidPubkeyHash = InvalidPubkeyHash
    class EthSignerError(ZkSignerError):
        def __str__(self):
            return "ZkSignerError.EthSignerError({})".format(repr(super().__str__()))

    ZkSignerError.EthSignerError = EthSignerError
    class StarkSignerError(ZkSignerError):
        def __str__(self):
            return "ZkSignerError.StarkSignerError({})".format(repr(super().__str__()))

    ZkSignerError.StarkSignerError = StarkSignerError
ZkSignerError = UniFFIExceptionTmpNamespace.ZkSignerError
del UniFFIExceptionTmpNamespace


class FfiConverterTypeZkSignerError(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return ZkSignerError.CustomError(
                FfiConverterString.read(buf),
            )
        if variant == 2:
            return ZkSignerError.InvalidSignature(
                FfiConverterString.read(buf),
            )
        if variant == 3:
            return ZkSignerError.InvalidPrivKey(
                FfiConverterString.read(buf),
            )
        if variant == 4:
            return ZkSignerError.InvalidSeed(
                FfiConverterString.read(buf),
            )
        if variant == 5:
            return ZkSignerError.InvalidPubkey(
                FfiConverterString.read(buf),
            )
        if variant == 6:
            return ZkSignerError.InvalidPubkeyHash(
                FfiConverterString.read(buf),
            )
        if variant == 7:
            return ZkSignerError.EthSignerError(
                FfiConverterString.read(buf),
            )
        if variant == 8:
            return ZkSignerError.StarkSignerError(
                FfiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def write(value, buf):
        if isinstance(value, ZkSignerError.CustomError):
            buf.writeI32(1)
        if isinstance(value, ZkSignerError.InvalidSignature):
            buf.writeI32(2)
        if isinstance(value, ZkSignerError.InvalidPrivKey):
            buf.writeI32(3)
        if isinstance(value, ZkSignerError.InvalidSeed):
            buf.writeI32(4)
        if isinstance(value, ZkSignerError.InvalidPubkey):
            buf.writeI32(5)
        if isinstance(value, ZkSignerError.InvalidPubkeyHash):
            buf.writeI32(6)
        if isinstance(value, ZkSignerError.EthSignerError):
            buf.writeI32(7)
        if isinstance(value, ZkSignerError.StarkSignerError):
            buf.writeI32(8)



class FfiConverterOptionalString(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeZkLinkSignature(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeZkLinkSignature.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeZkLinkSignature.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalSequenceUInt8(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterSequenceUInt8.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterSequenceUInt8.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeH256(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeH256.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeH256.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypePackedEthSignature(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypePackedEthSignature.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypePackedEthSignature.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeTxLayer1Signature(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeTxLayer1Signature.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeTxLayer1Signature.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterSequenceUInt8(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterUInt8.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterUInt8.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeContract(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeContract.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeContract.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeContractPrice(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeContractPrice.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeContractPrice.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeFundingInfo(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeFundingInfo.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeFundingInfo.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeSpotPriceInfo(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeSpotPriceInfo.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeSpotPriceInfo.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeAccountId(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeAccountId.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeAccountId.read(buf) for i in range(count)
        ]


class FfiConverterTypeAccountId:
    @staticmethod
    def write(value, buf):
        FfiConverterUInt32.write(value, buf)

    @staticmethod
    def read(buf):
        return FfiConverterUInt32.read(buf)

    @staticmethod
    def lift(value):
        return FfiConverterUInt32.lift(value)

    @staticmethod
    def lower(value):
        return FfiConverterUInt32.lower(value)


class FfiConverterTypeAddress:
    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return FfiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return FfiConverterString.lift(value)

    @staticmethod
    def lower(value):
        return FfiConverterString.lower(value)


class FfiConverterTypeBigUint:
    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return FfiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return FfiConverterString.lift(value)

    @staticmethod
    def lower(value):
        return FfiConverterString.lower(value)


class FfiConverterTypeBlockNumber:
    @staticmethod
    def write(value, buf):
        FfiConverterUInt32.write(value, buf)

    @staticmethod
    def read(buf):
        return FfiConverterUInt32.read(buf)

    @staticmethod
    def lift(value):
        return FfiConverterUInt32.lift(value)

    @staticmethod
    def lower(value):
        return FfiConverterUInt32.lower(value)


class FfiConverterTypeChainId:
    @staticmethod
    def write(value, buf):
        FfiConverterUInt8.write(value, buf)

    @staticmethod
    def read(buf):
        return FfiConverterUInt8.read(buf)

    @staticmethod
    def lift(value):
        return FfiConverterUInt8.lift(value)

    @staticmethod
    def lower(value):
        return FfiConverterUInt8.lower(value)


class FfiConverterTypeEthBlockId:
    @staticmethod
    def write(value, buf):
        FfiConverterUInt64.write(value, buf)

    @staticmethod
    def read(buf):
        return FfiConverterUInt64.read(buf)

    @staticmethod
    def lift(value):
        return FfiConverterUInt64.lift(value)

    @staticmethod
    def lower(value):
        return FfiConverterUInt64.lower(value)


class FfiConverterTypeH256:
    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return FfiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return FfiConverterString.lift(value)

    @staticmethod
    def lower(value):
        return FfiConverterString.lower(value)


class FfiConverterTypeMarginId:
    @staticmethod
    def write(value, buf):
        FfiConverterUInt8.write(value, buf)

    @staticmethod
    def read(buf):
        return FfiConverterUInt8.read(buf)

    @staticmethod
    def lift(value):
        return FfiConverterUInt8.lift(value)

    @staticmethod
    def lower(value):
        return FfiConverterUInt8.lower(value)


class FfiConverterTypeNonce:
    @staticmethod
    def write(value, buf):
        FfiConverterUInt32.write(value, buf)

    @staticmethod
    def read(buf):
        return FfiConverterUInt32.read(buf)

    @staticmethod
    def lift(value):
        return FfiConverterUInt32.lift(value)

    @staticmethod
    def lower(value):
        return FfiConverterUInt32.lower(value)


class FfiConverterTypePackedEthSignature:
    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return FfiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return FfiConverterString.lift(value)

    @staticmethod
    def lower(value):
        return FfiConverterString.lower(value)


class FfiConverterTypePackedPublicKey:
    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return FfiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return FfiConverterString.lift(value)

    @staticmethod
    def lower(value):
        return FfiConverterString.lower(value)


class FfiConverterTypePackedSignature:
    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return FfiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return FfiConverterString.lift(value)

    @staticmethod
    def lower(value):
        return FfiConverterString.lower(value)


class FfiConverterTypePairId:
    @staticmethod
    def write(value, buf):
        FfiConverterUInt16.write(value, buf)

    @staticmethod
    def read(buf):
        return FfiConverterUInt16.read(buf)

    @staticmethod
    def lift(value):
        return FfiConverterUInt16.lift(value)

    @staticmethod
    def lower(value):
        return FfiConverterUInt16.lower(value)


class FfiConverterTypePriorityOpId:
    @staticmethod
    def write(value, buf):
        FfiConverterUInt64.write(value, buf)

    @staticmethod
    def read(buf):
        return FfiConverterUInt64.read(buf)

    @staticmethod
    def lift(value):
        return FfiConverterUInt64.lift(value)

    @staticmethod
    def lower(value):
        return FfiConverterUInt64.lower(value)


class FfiConverterTypePubKeyHash:
    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return FfiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return FfiConverterString.lift(value)

    @staticmethod
    def lower(value):
        return FfiConverterString.lower(value)


class FfiConverterTypeSlotId:
    @staticmethod
    def write(value, buf):
        FfiConverterUInt32.write(value, buf)

    @staticmethod
    def read(buf):
        return FfiConverterUInt32.read(buf)

    @staticmethod
    def lift(value):
        return FfiConverterUInt32.lift(value)

    @staticmethod
    def lower(value):
        return FfiConverterUInt32.lower(value)


class FfiConverterTypeStarkEip712Signature:
    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return FfiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return FfiConverterString.lift(value)

    @staticmethod
    def lower(value):
        return FfiConverterString.lower(value)


class FfiConverterTypeSubAccountId:
    @staticmethod
    def write(value, buf):
        FfiConverterUInt8.write(value, buf)

    @staticmethod
    def read(buf):
        return FfiConverterUInt8.read(buf)

    @staticmethod
    def lift(value):
        return FfiConverterUInt8.lift(value)

    @staticmethod
    def lower(value):
        return FfiConverterUInt8.lower(value)


class FfiConverterTypeTimeStamp:
    @staticmethod
    def write(value, buf):
        FfiConverterUInt32.write(value, buf)

    @staticmethod
    def read(buf):
        return FfiConverterUInt32.read(buf)

    @staticmethod
    def lift(value):
        return FfiConverterUInt32.lift(value)

    @staticmethod
    def lower(value):
        return FfiConverterUInt32.lower(value)


class FfiConverterTypeTokenId:
    @staticmethod
    def write(value, buf):
        FfiConverterUInt32.write(value, buf)

    @staticmethod
    def read(buf):
        return FfiConverterUInt32.read(buf)

    @staticmethod
    def lift(value):
        return FfiConverterUInt32.lift(value)

    @staticmethod
    def lower(value):
        return FfiConverterUInt32.lower(value)


class FfiConverterTypeTxHash:
    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return FfiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return FfiConverterString.lift(value)

    @staticmethod
    def lower(value):
        return FfiConverterString.lower(value)


class FfiConverterTypeTxLayer1Signature:
    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return FfiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return FfiConverterString.lift(value)

    @staticmethod
    def lower(value):
        return FfiConverterString.lower(value)


class FfiConverterTypeZkLinkAddress:
    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return FfiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return FfiConverterString.lift(value)

    @staticmethod
    def lower(value):
        return FfiConverterString.lower(value)


class FfiConverterTypeZkLinkTx:
    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return FfiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return FfiConverterString.lift(value)

    @staticmethod
    def lower(value):
        return FfiConverterString.lower(value)

def verify_musig(signature,msg):
    signature = signature
    
    msg = list(int(x) for x in msg)
    
    return FfiConverterBool.lift(rust_call(_UniFFILib.zklink_sdk_f180_verify_musig,
        FfiConverterTypeZkLinkSignature.lower(signature),
        FfiConverterSequenceUInt8.lower(msg)))



def get_public_key_hash(public_key):
    public_key = public_key
    
    return FfiConverterTypePubKeyHash.lift(rust_call(_UniFFILib.zklink_sdk_f180_get_public_key_hash,
        FfiConverterTypePackedPublicKey.lower(public_key)))



def zklink_main_net_url():
    return FfiConverterString.lift(rust_call(_UniFFILib.zklink_sdk_f180_zklink_main_net_url,))



def zklink_test_net_url():
    return FfiConverterString.lift(rust_call(_UniFFILib.zklink_sdk_f180_zklink_test_net_url,))



def eth_signature_of_change_pubkey(tx,eth_signer):
    tx = tx
    
    eth_signer = eth_signer
    
    return FfiConverterTypePackedEthSignature.lift(rust_call_with_error(FfiConverterTypeSignError,_UniFFILib.zklink_sdk_f180_eth_signature_of_change_pubkey,
        FfiConverterTypeChangePubKey.lower(tx),
        FfiConverterTypeEthSigner.lower(eth_signer)))



def create_signed_change_pubkey(zklink_signer,tx,eth_auth_data):
    zklink_signer = zklink_signer
    
    tx = tx
    
    eth_auth_data = eth_auth_data
    
    return FfiConverterTypeChangePubKey.lift(rust_call_with_error(FfiConverterTypeSignError,_UniFFILib.zklink_sdk_f180_create_signed_change_pubkey,
        FfiConverterTypeZkLinkSigner.lower(zklink_signer),
        FfiConverterTypeChangePubKey.lower(tx),
        FfiConverterTypeChangePubKeyAuthData.lower(eth_auth_data)))



__all__ = [
    "InternalError",
    "ChangePubKeyAuthData",
    "ChangePubKeyAuthRequest",
    "L1SignerType",
    "L1Type",
    "Parameter",
    "TypedDataMessage",
    "AutoDeleveragingBuilder",
    "ChangePubKeyBuilder",
    "ContractBuilder",
    "ContractMatchingBuilder",
    "ContractPrice",
    "Create2Data",
    "DepositBuilder",
    "ForcedExitBuilder",
    "FullExitBuilder",
    "FundingBuilder",
    "FundingInfo",
    "LiquidationBuilder",
    "Message",
    "OraclePrices",
    "OrderMatchingBuilder",
    "SpotPriceInfo",
    "TransferBuilder",
    "TxMessage",
    "TxSignature",
    "UpdateGlobalVarBuilder",
    "WithdrawBuilder",
    "ZkLinkSignature",
    "verify_musig",
    "get_public_key_hash",
    "zklink_main_net_url",
    "zklink_test_net_url",
    "eth_signature_of_change_pubkey",
    "create_signed_change_pubkey",
    "Deposit",
    "Withdraw",
    "ChangePubKey",
    "ForcedExit",
    "FullExit",
    "Transfer",
    "Order",
    "OrderMatching",
    "Contract",
    "AutoDeleveraging",
    "ContractMatching",
    "Funding",
    "Liquidation",
    "UpdateGlobalVar",
    "EthSigner",
    "TypedData",
    "StarkSigner",
    "ZkLinkSigner",
    "Signer",
    "EthSignerError",
    "SignError",
    "StarkSignerError",
    "TypeError",
    "ZkSignerError",
]

